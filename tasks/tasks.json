{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository",
      "description": "Initialize the project repository with Next.js, React, and TailwindCSS + DaisyUI as specified in the PRD.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new Next.js project with TypeScript support. Install and configure TailwindCSS with DaisyUI for UI components. Set up the basic folder structure following Next.js conventions. Initialize Git repository and create an initial commit.",
      "testStrategy": "Verify that the development server runs without errors and the basic Next.js page loads correctly with TailwindCSS styles applied."
    },
    {
      "id": 2,
      "title": "Create Basic Project Structure",
      "description": "Set up the foundational project structure including pages, components, and utility folders.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create folders for components, hooks, utils, types, and pages. Set up a basic layout component with header and footer. Create placeholder files for main pages based on the user flow. Configure global styles and theme variables in Tailwind config.",
      "testStrategy": "Review the project structure to ensure it follows best practices and meets the requirements. Test that the layout component renders correctly."
    },
    {
      "id": 3,
      "title": "Implement Currency API Integration",
      "description": "Set up the integration with CurrencyAPI for exchange rate data as specified in the PRD.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create a utility function to fetch exchange rates from CurrencyAPI. Implement caching to minimize API calls. Create a context provider to make exchange rates available throughout the application. Include error handling and fallback values.",
      "testStrategy": "Test API integration by making test calls and verifying response format. Ensure caching works correctly and that the context provider properly distributes currency data."
    },
    {
      "id": 4,
      "title": "Design Data Models",
      "description": "Create TypeScript interfaces for all data models mentioned in the conceptual data model section.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Define TypeScript interfaces for Household, Income, Housing, Transport, Lifestyle, Education, Healthcare, EmergencyBuffer, FX, and Summary. Include all fields mentioned in the PRD with appropriate types. Create utility functions for calculations and data transformations.",
      "testStrategy": "Review interfaces for completeness against the PRD requirements. Write unit tests for utility functions to ensure correct calculations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Core Financial Entity Interfaces",
          "description": "Create TypeScript interfaces for the fundamental financial entities: Household and Income models with all required properties and types.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new file `models/core.ts`\n2. Define the Household interface with properties for household members, dependents, location data, etc.\n3. Define the Income interface with properties for income sources, salary details, investment income, etc.\n4. Add JSDoc comments to document each property's purpose and constraints\n5. Include appropriate TypeScript types (string, number, boolean, Date, etc.)\n6. Define any necessary enum types for categorical fields\n\nTesting approach:\n- Create sample objects that implement these interfaces\n- Verify type checking works correctly with TypeScript compiler\n- Ensure all fields from the PRD are represented",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 2,
          "title": "Define Expense Category Interfaces",
          "description": "Create TypeScript interfaces for expense-related models: Housing, Transport, Lifestyle, Education, and Healthcare.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a new file `models/expenses.ts`\n2. Define the Housing interface with properties for mortgage/rent, utilities, maintenance, etc.\n3. Define the Transport interface with properties for vehicles, public transport, fuel costs, etc.\n4. Define the Lifestyle interface with properties for entertainment, dining, subscriptions, etc.\n5. Define the Education interface with properties for tuition, books, courses, etc.\n6. Define the Healthcare interface with properties for insurance, medications, procedures, etc.\n7. Add JSDoc comments for all properties\n8. Ensure consistent typing conventions with core models\n\nTesting approach:\n- Create sample objects for each expense category\n- Verify type compatibility with the Household model\n- Test with both minimal and comprehensive data examples",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 3,
          "title": "Define Financial Planning Interfaces",
          "description": "Create TypeScript interfaces for financial planning models: EmergencyBuffer, FX (Foreign Exchange), and Summary.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Create a new file `models/planning.ts`\n2. Define the EmergencyBuffer interface with properties for savings targets, current amounts, etc.\n3. Define the FX interface with properties for currency exchange rates, foreign holdings, etc.\n4. Define the Summary interface that aggregates financial data from other models\n5. Ensure Summary interface can reference other model types appropriately\n6. Add calculated fields that will be derived from other models\n7. Document relationships between these models and previously defined ones\n\nTesting approach:\n- Create sample objects implementing these interfaces\n- Verify they can correctly reference other model types\n- Test with realistic financial planning scenarios",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 4,
          "title": "Implement Model Relationship Types",
          "description": "Define TypeScript types that express relationships between different financial models and create a unified financial profile type.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Create a new file `models/relationships.ts`\n2. Define a FinancialProfile interface that combines all previously defined models\n3. Create appropriate nested type structures to represent hierarchical relationships\n4. Define union types for fields that can accept multiple types of values\n5. Create index types for lookups between related models\n6. Define mapping types between related entities (e.g., household member to income sources)\n7. Ensure type safety across model relationships\n\nTesting approach:\n- Create a complete financial profile object\n- Test traversing relationships between models\n- Verify TypeScript compiler catches inconsistent relationships",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 5,
          "title": "Create Calculation Utility Functions",
          "description": "Implement utility functions for financial calculations across models, such as total income, expense ratios, and savings projections.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a new file `utils/calculations.ts`\n2. Implement functions for calculating total household income\n3. Implement functions for calculating expense totals by category\n4. Create functions for determining expense-to-income ratios\n5. Implement savings rate and projection calculations\n6. Add emergency fund adequacy calculations\n7. Create utility functions for currency conversion using FX rates\n8. Ensure all functions are properly typed with the model interfaces\n\nTesting approach:\n- Write unit tests with sample financial data\n- Verify calculations match expected results\n- Test edge cases (zero income, negative values, etc.)\n- Ensure type safety for all function parameters and return values",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 6,
          "title": "Implement Data Transformation Utilities",
          "description": "Create utility functions for transforming, validating, and normalizing financial data across all models.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Implementation steps:\n1. Create a new file `utils/transformations.ts`\n2. Implement functions to convert raw data inputs to model-compliant objects\n3. Create validation functions to check data integrity and constraints\n4. Implement normalization functions for standardizing data formats\n5. Add utility functions for data aggregation across models\n6. Create serialization/deserialization functions for storage and retrieval\n7. Implement data migration utilities for handling model changes\n8. Add helper functions for generating default/empty model instances\n\nTesting approach:\n- Test with various input data formats\n- Verify validation correctly identifies invalid data\n- Test transformation of incomplete data\n- Ensure round-trip transformations preserve data integrity\n- Verify compatibility with calculation utilities",
          "status": "done",
          "parentTaskId": 4
        }
      ]
    },
    {
      "id": 5,
      "title": "Create Country Selection Component",
      "description": "Implement the origin and destination country selector as the first step in the user flow.",
      "status": "done",
      "dependencies": [
        2,
        4
      ],
      "priority": "high",
      "details": "Create a dropdown component for selecting origin and destination countries. For MVP, focus on UK to Portugal path but design for extensibility. Include country flags and names. Store selection in application state.",
      "testStrategy": "Test the component renders correctly with all required countries. Verify that selection updates the application state correctly."
    },
    {
      "id": 6,
      "title": "Implement Household Setup Component",
      "description": "Create the component for users to define their household composition.",
      "status": "done",
      "dependencies": [
        2,
        4
      ],
      "priority": "high",
      "details": "Build a form component allowing users to specify number of people and their age groups (Baby, Primary, Secondary, College, Adult, Parent, Grandparent). Include input for duration of stay in years. Store this information in application state.",
      "testStrategy": "Test form validation for all inputs. Verify that household data is correctly stored and accessible to other components."
    },
    {
      "id": 7,
      "title": "Develop Residency Regime Selector",
      "description": "Create a component to select the tax/residency regime (e.g., NHR toggle for Portugal).",
      "status": "done",
      "dependencies": [
        5
      ],
      "priority": "high",
      "details": "Implement a toggle or dropdown for selecting residency regime. For MVP, focus on Portugal's NHR option. Include brief explanatory text about the selected regime. Connect selection to tax calculation logic.",
      "testStrategy": "Verify that toggling between regimes updates the state correctly. Test that explanatory text changes appropriately based on selection."
    },
    {
      "id": 8,
      "title": "Build Income Input Module",
      "description": "Create the comprehensive income input section for salaries, passive income, and one-off inflows.",
      "status": "done",
      "dependencies": [
        3,
        4,
        5
      ],
      "priority": "high",
      "details": "Implement form components for Partner 1 & 2 salaries with currency selection. Create add/remove functionality for multiple passive income sources with type, amount, and frequency inputs. Add one-off inflows section with date inputs. Show all values in both origin and destination currencies.",
      "testStrategy": "Test adding and removing income sources. Verify currency conversions are correct. Ensure all income types are correctly summed in calculations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Base Income State Management",
          "description": "Set up the core state management structure for all income types with appropriate interfaces and initial state values",
          "dependencies": [],
          "details": "Implementation steps:\n1. Define TypeScript interfaces for all income types (salary, passive, one-off)\n2. Create a central income state object with appropriate nested structure\n3. Implement reducer functions for adding, updating, and removing income entries\n4. Set up context provider to make income state available throughout the application\n5. Add utility functions for currency-related calculations\n6. Test the state management by manually triggering state changes and verifying the state updates correctly\n\n<info added on 2025-04-16T18:02:46.850Z>\n# Implementation Plan for Subtask 8.1 (Income State Management):\n\n1. **Approach:** Use React Context API (`createContext`, `useReducer`) and a custom hook (`useIncome`). This aligns with the existing `CurrencyContext.tsx` pattern. Avoid introducing Zustand/Redux at this stage.\n2. **Interfaces:** Define detailed TypeScript interfaces in `src/types/income.types.ts` for `SalaryDetails`, `PassiveIncome`, `OneOffInflow`, and the main `IncomeState`. Ensure types accommodate currency selection and frequency where needed.\n3. **Reducer:** Create `incomeReducer` in a new file `src/context/IncomeContext.tsx`. Implement actions:\n   * `UPDATE_PARTNER1_SALARY`\n   * `UPDATE_PARTNER2_SALARY`\n   * `ADD_PASSIVE_INCOME`\n   * `UPDATE_PASSIVE_INCOME` (by ID)\n   * `REMOVE_PASSIVE_INCOME` (by ID)\n   * `ADD_ONE_OFF_INFLOW`\n   * `UPDATE_ONE_OFF_INFLOW` (by ID)\n   * `REMOVE_ONE_OFF_INFLOW` (by ID)\n   * `SET_INCOME_STATE` (for loading initial/saved state)\n   * `UPDATE_BASE_CURRENCY` (or handle via separate context)\n   * `UPDATE_EXCHANGE_RATES` (or handle via separate context)\n4. **Context & Provider:** Define `IncomeContext` and `IncomeProvider` component in `src/context/IncomeContext.tsx`. The provider will use `useReducer` with the `incomeReducer` and provide `state` and `dispatch`.\n5. **Hook:** Create `useIncome` hook in `src/context/IncomeContext.tsx` for easy consumption.\n6. **Integration:** Wrap the application layout (likely in `src/app/layout.tsx` below `CurrencyProvider` or within `src/app/page.tsx`) with `<IncomeProvider>`.\n7. **Initial State:** Define the `initialIncomeState` according to the `IncomeState` interface, using defaults like empty arrays for lists and potentially null/undefined for salaries until set.\n</info added on 2025-04-16T18:02:46.850Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Implement Salary Input Components",
          "description": "Build form components for Partner 1 & Partner 2 salary inputs with currency selection",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a reusable salary input component with fields for amount and currency\n2. Implement separate instances for Partner 1 and Partner 2\n3. Add validation for numeric inputs and required fields\n4. Connect components to the income state management from subtask 1\n5. Style the components according to the application design system\n6. Test the components by entering various salary values and verifying the state updates correctly\n7. Ensure proper handling of currency selection changes\n\n<info added on 2025-04-16T18:21:48.773Z>\n# Implementation Plan (Subtask 8.2):\n\n1. **File Structure:** Create `src/components/Income/SalaryInput.tsx` for the reusable component and `src/components/Income/IncomeModule.tsx` as a container.\n2. **Reusable Component (`SalaryInput.tsx`):**\n   * Define `SalaryInputProps`: `partnerLabel: string`, `value: SalaryDetails | undefined`, `onUpdate: (payload: SalaryDetails | undefined) => void`.\n   * Component receives these props.\n   * Use internal state (`useState`) for input values (amount, frequency, currency) derived initially from the `value` prop.\n   * Render labeled inputs:\n       * Amount (`<input type=\"number\">`)\n       * Frequency (`<select>` with 'Annual', 'Monthly')\n       * Currency (`<select>`). Use `useCurrency` hook to get available `rates` and populate options (displaying currency codes).\n   * On input changes (`onChange` or `onBlur`), update internal state.\n   * Use `useEffect` hook to call the `onUpdate` prop whenever the internal state representing a complete `SalaryDetails` object changes. Handle the case where inputs are incomplete (e.g., amount is empty) by potentially calling `onUpdate(undefined)`.\n   * Apply Tailwind/DaisyUI classes (`input`, `select`, `label`, `form-control`).\n3. **Container Component (`IncomeModule.tsx`):**\n   * Import `SalaryInput` and `useIncome`.\n   * Call `useIncome` to get `state` and `dispatch`.\n   * Define handler functions:\n       * `handleUpdatePartner1(payload: SalaryDetails | undefined)`: Calls `dispatch({ type: 'UPDATE_PARTNER1_SALARY', payload })`.\n       * `handleUpdatePartner2(payload: SalaryDetails | undefined)`: Calls `dispatch({ type: 'UPDATE_PARTNER2_SALARY', payload })`.\n   * Render a container `div` (e.g., with heading 'Income').\n   * Render `<SalaryInput partnerLabel=\"Partner 1\" value={state.partner1Salary} onUpdate={handleUpdatePartner1} />`.\n   * Render `<SalaryInput partnerLabel=\"Partner 2\" value={state.partner2Salary} onUpdate={handleUpdatePartner2} />`.\n4. **Integration (`page.tsx`):**\n   * Import `IncomeModule`.\n   * Add `<IncomeModule />` to the main page component's render structure.\n</info added on 2025-04-16T18:21:48.773Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Build Passive Income Management Section",
          "description": "Create the passive income section with add/remove functionality and inputs for type, amount, and frequency",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Develop a passive income entry component with fields for income type (dropdown), amount, frequency, and currency\n2. Implement an 'Add Income Source' button that creates a new entry in the state\n3. Add a remove button for each passive income entry\n4. Connect the components to the income state management\n5. Implement validation for all input fields\n6. Test adding multiple passive income sources and removing them\n7. Verify that all input changes correctly update the state\n\n<info added on 2025-04-16T18:24:24.122Z>\n# Implementation Plan (Subtask 8.3):\n\n1. **File Structure:** Create `src/components/Income/PassiveIncomeItem.tsx` for the individual item rows.\n2. **Item Component (`PassiveIncomeItem.tsx`):**\n   * Define `PassiveIncomeItemProps`: `item: PassiveIncome`, `onUpdate: (updatedItem: PassiveIncome) => void`, `onRemove: (id: string) => void`.\n   * Component receives these props.\n   * Use internal state (`useState`) for input values (type, amount, frequency, currency) derived from the `item` prop.\n   * Render labeled inputs:\n       * Type (`<input type=\"text\">` or `<select>` if predefined types exist)\n       * Amount (`<input type=\"number\">`)\n       * Frequency (`<select>` with options from `IncomeFrequency` type)\n       * Currency (`<select>` using `useCurrency` hook).\n   * Render a \"Remove\" button (e.g., using an icon) that calls `onRemove(item.id)`.\n   * On input changes, update internal state.\n   * Use `useEffect` to call `onUpdate` prop whenever the internal state forms a complete, valid, and *changed* `PassiveIncome` object (compared to the original `item` prop).\n   * Apply Tailwind/DaisyUI styling for inputs, button, and row layout.\n3. **Container Component (`IncomeModule.tsx` - Modify):\n   * Add a new `div` section below salaries with a heading like \"Passive Income\".\n   * Import `PassiveIncomeItem`.\n   * Define handler functions:\n       * `handleUpdatePassiveIncome(updatedItem: PassiveIncome)`: Dispatches `{ type: 'UPDATE_PASSIVE_INCOME', payload: updatedItem }`.\n       * `handleRemovePassiveIncome(id: string)`: Dispatches `{ type: 'REMOVE_PASSIVE_INCOME', payload: { id } }`.\n       * `handleAddPassiveIncome()`: Dispatches `{ type: 'ADD_PASSIVE_INCOME', payload: { type: '', amount: 0, frequency: 'Monthly', currency: '' /* Default Currency? */ } }`.\n   * Map over `state.passiveIncomes`:\n       * For each `income` item, render `<PassiveIncomeItem key={income.id} item={income} onUpdate={handleUpdatePassiveIncome} onRemove={handleRemovePassiveIncome} />`.\n   * Add an \"Add Passive Income\" button (`<button>`) at the end of the section, calling `handleAddPassiveIncome` onClick.\n</info added on 2025-04-16T18:24:24.122Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 4,
          "title": "Create One-Off Inflows Section",
          "description": "Implement the one-off inflows section with date, amount, and description inputs",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Build a one-off inflow entry component with date picker, amount input, description field, and currency selection\n2. Add functionality to create and remove one-off inflow entries\n3. Connect the components to the income state management\n4. Implement validation for required fields and proper date formats\n5. Ensure the date picker has appropriate date range restrictions if needed\n6. Test adding and removing one-off inflows and verify state updates\n7. Check that date inputs are properly formatted and stored\n\n<info added on 2025-04-16T18:33:52.812Z>\n# Implementation Plan (Subtask 8.4):\n\n## Component Implementation Details\n\n### OneOffInflowItem.tsx\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { useCurrencies } from '../../hooks/useCurrencies';\nimport { OneOffInflow } from '../../types/income';\n\ninterface OneOffInflowItemProps {\n  item: OneOffInflow;\n  onUpdate: (updatedItem: OneOffInflow) => void;\n  onRemove: (id: string) => void;\n}\n\nexport const OneOffInflowItem: React.FC<OneOffInflowItemProps> = ({ item, onUpdate, onRemove }) => {\n  const { currencies, defaultCurrency } = useCurrencies();\n  const [description, setDescription] = useState(item.description || '');\n  const [amount, setAmount] = useState(item.amount || 0);\n  const [currency, setCurrency] = useState(item.currency || defaultCurrency);\n  const [date, setDate] = useState(item.date || new Date().toISOString().split('T')[0]);\n  \n  useEffect(() => {\n    // Only update if values have changed and are valid\n    if (description && amount > 0 && currency && date &&\n        (description !== item.description || \n         amount !== item.amount ||\n         currency !== item.currency ||\n         date !== item.date)) {\n      onUpdate({\n        ...item,\n        description,\n        amount,\n        currency,\n        date\n      });\n    }\n  }, [description, amount, currency, date]);\n\n  return (\n    <div className=\"card bg-base-200 shadow-sm p-4 mb-2\">\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-3\">\n        <div className=\"form-control\">\n          <label className=\"label\">\n            <span className=\"label-text\">Date</span>\n          </label>\n          <input\n            type=\"date\"\n            className=\"input input-bordered w-full\"\n            value={date}\n            onChange={(e) => setDate(e.target.value)}\n          />\n        </div>\n        \n        <div className=\"form-control\">\n          <label className=\"label\">\n            <span className=\"label-text\">Amount</span>\n          </label>\n          <input\n            type=\"number\"\n            className=\"input input-bordered w-full\"\n            value={amount}\n            min=\"0\"\n            step=\"0.01\"\n            onChange={(e) => setAmount(parseFloat(e.target.value) || 0)}\n          />\n        </div>\n        \n        <div className=\"form-control\">\n          <label className=\"label\">\n            <span className=\"label-text\">Currency</span>\n          </label>\n          <select \n            className=\"select select-bordered w-full\"\n            value={currency}\n            onChange={(e) => setCurrency(e.target.value)}\n          >\n            {currencies.map(curr => (\n              <option key={curr} value={curr}>{curr}</option>\n            ))}\n          </select>\n        </div>\n        \n        <div className=\"form-control\">\n          <label className=\"label\">\n            <span className=\"label-text\">Description</span>\n          </label>\n          <div className=\"flex\">\n            <input\n              type=\"text\"\n              className=\"input input-bordered w-full\"\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n            />\n            <button \n              className=\"btn btn-error ml-2\" \n              onClick={() => onRemove(item.id)}\n            >\n              <i className=\"fas fa-trash\"></i>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n### State Management Updates\nAdd these reducer cases to handle one-off inflows:\n\n```typescript\n// In incomeReducer.ts\ncase 'ADD_ONE_OFF_INFLOW':\n  return {\n    ...state,\n    oneOffInflows: [\n      ...state.oneOffInflows,\n      {\n        id: generateId(), // Implement or import this utility function\n        description: '',\n        amount: 0,\n        currency: state.defaultCurrency || 'USD',\n        date: new Date().toISOString().split('T')[0]\n      }\n    ]\n  };\n\ncase 'UPDATE_ONE_OFF_INFLOW':\n  return {\n    ...state,\n    oneOffInflows: state.oneOffInflows.map(item => \n      item.id === action.payload.id ? action.payload : item\n    )\n  };\n\ncase 'REMOVE_ONE_OFF_INFLOW':\n  return {\n    ...state,\n    oneOffInflows: state.oneOffInflows.filter(item => item.id !== action.payload.id)\n  };\n```\n\n### Types Definition\n```typescript\n// In types/income.ts\nexport interface OneOffInflow {\n  id: string;\n  description: string;\n  amount: number;\n  currency: string;\n  date: string; // ISO format date string\n}\n```\n\n### Validation Functions\n```typescript\n// Utility function for validation\nexport const validateOneOffInflow = (inflow: OneOffInflow): string[] => {\n  const errors: string[] = [];\n  \n  if (!inflow.description.trim()) {\n    errors.push('Description is required');\n  }\n  \n  if (!inflow.amount || inflow.amount <= 0) {\n    errors.push('Amount must be greater than zero');\n  }\n  \n  if (!inflow.currency) {\n    errors.push('Currency is required');\n  }\n  \n  if (!inflow.date || !/^\\d{4}-\\d{2}-\\d{2}$/.test(inflow.date)) {\n    errors.push('Valid date is required (YYYY-MM-DD)');\n  }\n  \n  return errors;\n}\n```\n\n### Testing Considerations\n1. Test adding one-off inflows with various date formats\n2. Verify currency conversion works correctly when calculating totals\n3. Test edge cases like extremely large amounts\n4. Ensure date validation works properly\n5. Test sorting of one-off inflows by date\n</info added on 2025-04-16T18:33:52.812Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 5,
          "title": "Implement Currency Conversion Display",
          "description": "Add functionality to display all income values in both origin and destination currencies",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a currency conversion service that can convert between different currencies\n2. Modify the income display components to show values in both original and destination currencies\n3. Implement a currency selection component for setting the destination currency\n4. Add visual indicators to distinguish between original and converted values\n5. Ensure currency symbols are displayed correctly\n6. Test the conversion by changing currencies and verifying the displayed values update correctly\n7. Add loading states for when conversion rates are being fetched",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 6,
          "title": "Integrate and Finalize Income Module",
          "description": "Combine all income components into a cohesive module with consistent styling and validation",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Implementation steps:\n1. Create a parent Income Module component that incorporates all income sections\n2. Implement consistent styling across all income components\n3. Add section headers and descriptive text for each income type\n4. Create a summary section that displays total income from all sources\n5. Implement form-level validation that checks for required fields across all sections\n6. Add appropriate error messages and validation feedback\n7. Test the complete module by entering various income scenarios and verifying all functionality works together\n8. Ensure responsive design works on different screen sizes",
          "status": "done",
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Housing Module",
      "description": "Create the housing section with rent/buy toggle and relevant inputs for each option.",
      "status": "done",
      "dependencies": [
        3,
        4
      ],
      "priority": "high",
      "details": "Build a toggle between rent and buy options. For buying, include inputs for property price, down payment (fixed or %), mortgage term, and interest rate with calculated monthly payment. For renting, include monthly rent input. Add fields for annual maintenance, insurance, and property tax. Include option to model future housing upgrade.",
      "testStrategy": "Test mortgage calculation accuracy. Verify that toggling between rent/buy shows/hides appropriate fields. Test that housing costs are correctly reflected in summary calculations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Housing Module Base Structure with Rent/Buy Toggle",
          "description": "Implement the basic structure of the housing module with a toggle switch between rent and buy options",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a new Housing component with a container layout\n2. Implement a toggle switch component that allows users to select between 'Rent' and 'Buy' options\n3. Set up state management to track the selected option (rent/buy)\n4. Create conditional rendering logic based on the toggle state\n5. Add appropriate styling for the module container and toggle\n6. Implement event handlers for the toggle to update the state\n\nTesting approach:\n- Verify the toggle switches correctly between rent and buy\n- Confirm the UI updates appropriately when toggle changes\n- Test responsive layout on different screen sizes",
          "status": "done",
          "parentTaskId": 9
        },
        {
          "id": 2,
          "title": "Implement Buy Option Input Fields and Validation",
          "description": "Create all input fields required for the buy option, including property price, down payment options, mortgage term, and interest rate",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Create input fields for property price with currency formatting\n2. Implement down payment section with radio buttons to choose between fixed amount or percentage\n3. Add conditional input field based on down payment selection ($ amount or % value)\n4. Create dropdown or slider for mortgage term selection (years)\n5. Add interest rate input with percentage formatting\n6. Implement validation for all fields (non-negative values, reasonable ranges)\n7. Store all input values in state\n\nTesting approach:\n- Test input validation for each field\n- Verify conditional rendering of down payment options\n- Test edge cases (very large numbers, zero values)\n- Confirm all inputs are correctly stored in state",
          "status": "done",
          "parentTaskId": 9
        },
        {
          "id": 3,
          "title": "Implement Rent Option Input Fields",
          "description": "Create the input field for monthly rent amount with appropriate validation",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Create input field for monthly rent with currency formatting\n2. Implement validation for the rent input (non-negative values)\n3. Store rent value in state\n4. Ensure proper display when rent option is selected\n5. Add any additional rent-specific fields if needed\n\nTesting approach:\n- Test input validation for rent field\n- Verify the field is only displayed when rent option is selected\n- Test edge cases (very large numbers, zero values)\n- Confirm rent value is correctly stored in state",
          "status": "done",
          "parentTaskId": 9
        },
        {
          "id": 4,
          "title": "Implement Common Housing Expense Fields",
          "description": "Add input fields for expenses common to both rent and buy options: annual maintenance, insurance, and property tax",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation details:\n1. Create input fields for annual maintenance costs with currency formatting\n2. Add insurance cost input with currency formatting\n3. Implement property tax input with option for percentage of property value or fixed amount\n4. Add appropriate labels and help text explaining each field\n5. Implement validation for all fields\n6. Store all values in state\n7. Ensure these fields appear regardless of rent/buy selection\n\nTesting approach:\n- Verify fields appear for both rent and buy options\n- Test input validation for each field\n- Confirm conditional property tax input works correctly\n- Test that values are correctly stored in state",
          "status": "done",
          "parentTaskId": 9
        },
        {
          "id": 5,
          "title": "Implement Mortgage Payment Calculator",
          "description": "Create the logic to calculate monthly mortgage payments based on user inputs and display the result",
          "dependencies": [
            2
          ],
          "details": "Implementation details:\n1. Implement mortgage calculation formula: M = P[r(1+r)^n]/[(1+r)^n-1] where:\n   - M = monthly payment\n   - P = principal (loan amount)\n   - r = monthly interest rate (annual rate / 12 / 100)\n   - n = number of payments (term in years * 12)\n2. Calculate loan amount based on property price minus down payment\n3. Create a display component to show the calculated monthly payment\n4. Update calculation whenever relevant inputs change\n5. Add formatting for currency display\n6. Include breakdown of payment (principal vs. interest) if desired\n\nTesting approach:\n- Test calculation with various input combinations\n- Verify calculation updates when inputs change\n- Compare results with known mortgage calculators\n- Test edge cases (very short/long terms, high/low interest rates)",
          "status": "done",
          "parentTaskId": 9
        },
        {
          "id": 6,
          "title": "Implement Future Housing Upgrade Modeling",
          "description": "Add functionality to model a future housing upgrade with timing and cost projections",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Implementation details:\n1. Create a collapsible section for future housing upgrade\n2. Add toggle to enable/disable future upgrade modeling\n3. Implement input for projected year of upgrade\n4. Add fields for estimated future property value/rent\n5. Create inputs for new mortgage terms if applicable\n6. Implement logic to calculate financial impact of the upgrade\n7. Display projected changes in monthly payments and overall financial impact\n8. Ensure all inputs have appropriate validation\n\nTesting approach:\n- Test enabling/disabling the future upgrade section\n- Verify all inputs work correctly and store values in state\n- Test calculations for financial impact\n- Confirm integration with the rest of the housing module\n- Test that future projections update when current housing inputs change",
          "status": "done",
          "parentTaskId": 9
        }
      ]
    },
    {
      "id": 10,
      "title": "Develop Transportation Module",
      "description": "Build the transportation section with car ownership options and public transport inputs.",
      "status": "done",
      "dependencies": [
        4
      ],
      "priority": "medium",
      "details": "Create car ownership toggle (Yes/No). If Yes, add type selection (Electric/Gas) and purchase/lease toggle. Include inputs for car cost, monthly fuel/charging, insurance, and maintenance. Add fields for public transport and ride-share monthly averages. Include travel card costs input.",
      "testStrategy": "Test that appropriate fields show/hide based on selections. Verify calculations for total transportation costs are accurate.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Transport Data Types",
          "description": "Create/update TypeScript interfaces in src/types/transport.types.ts to represent the state for this module (car ownership toggle, type, purchase/lease, costs, public transport fields).",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 2,
          "title": "Create Transport Context/State Management",
          "description": "Set up state management (likely using React Context + Reducer, similar to Income) to hold and update the transport data.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 3,
          "title": "Implement Transport UI Component Structure",
          "description": "Create the main TransportModule.tsx component and basic layout, including the Car Ownership (Yes/No) toggle.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 4,
          "title": "Implement Car Ownership Input Fields",
          "description": "Add the conditional input fields for when Car Ownership is 'Yes' (Type: Electric/Gas toggle, Purchase/Lease toggle, Car Cost, Fuel/Charging, Insurance, Maintenance inputs).",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 5,
          "title": "Implement Public Transport Input Fields",
          "description": "Add the input fields for public transport costs (e.g., Monthly Average, Ride-share Average, Travel Card Costs). These should likely always be visible, regardless of car ownership.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 6,
          "title": "Integrate Transport Module into Page",
          "description": "Add the TransportModule to app/page.tsx and ensure state is managed correctly (either via context or passed props).",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        },
        {
          "id": 7,
          "title": "Implement Transport Cost Calculation (Placeholder)",
          "description": "Create placeholder calculation functions (e.g., in src/utils/calculations/transport.calculations.ts) to sum up the total monthly transport cost based on the inputs.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 10
        }
      ]
    },
    {
      "id": 11,
      "title": "Create Lifestyle & Discretionary Costs Module",
      "description": "Implement the section for lifestyle spending, one-off purchases, travel, and home services.",
      "status": "done",
      "dependencies": [
        4
      ],
      "priority": "medium",
      "details": "Build input fields for monthly/annual general shopping spend. Create add/remove functionality for one-off big purchases. Include travel & holidays budget input. Add home services section with inputs for cleaner, babysitter, gardening, and pet care. Implement contingency field as fixed amount or percentage of lifestyle total.",
      "testStrategy": "Test adding and removing one-off purchases. Verify percentage-based contingency calculations. Ensure all lifestyle costs are correctly summed.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Monthly/Annual General Shopping Spend Input Fields",
          "description": "Create the input fields for users to enter their monthly and annual general shopping expenditures with appropriate validation and formatting.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create form components for monthly shopping budget input with currency formatting\n2. Add annual shopping budget input with toggle between showing monthly or annual view\n3. Implement validation to ensure positive numbers only\n4. Add tooltips explaining what should be included in general shopping\n5. Store input values in state and ensure they're included in overall calculations\n6. Test with various input values, including edge cases like zero values and very large numbers\n\n<info added on 2025-04-16T20:01:55.030Z>\nBased on your implementation progress, here's additional information to add to the subtask:\n\nThe implementation has been started with a solid foundation. Consider these technical enhancements:\n\n- Extend LifestyleContext.tsx to include specific state types: `interface LifestyleState { generalShoppingSpend: number; isAnnualView: boolean; }` \n- Implement currency formatting using Intl.NumberFormat for consistent display: `new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)`\n- Add debounce functionality to input fields to prevent excessive re-renders during user typing\n- Ensure the toggle between monthly/annual automatically recalculates values (multiply/divide by 12)\n- Implement form validation using React Hook Form or Formik with Yup schema validation\n- Add focus and blur event handlers to improve UX when entering currency values\n- Consider adding a reset button to clear input values\n- Implement proper keyboard accessibility for the frequency toggle component\n</info added on 2025-04-16T20:01:55.030Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 2,
          "title": "Build One-Off Big Purchases Add/Remove Functionality",
          "description": "Create a dynamic interface allowing users to add and remove planned one-off large purchases with details and costs.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Design a form component for adding one-off purchases with fields for item name, cost, and optional date/timeframe\n2. Implement an 'Add Purchase' button that creates a new entry in the list\n3. Create a display list of added purchases with individual delete buttons\n4. Add validation for required fields and proper number formatting\n5. Calculate and display the total of all one-off purchases\n6. Test adding multiple items, removing items, and ensuring totals update correctly\n\n<info added on 2025-04-16T20:04:37.983Z>\nImplementation Plan:\n1. Update LifestyleContext.tsx:\n   ```typescript\n   // Add to state interface\n   interface LifestyleState {\n     // existing properties\n     oneOffPurchases: Array<{\n       id: string;\n       name: string;\n       cost: number;\n       targetDate?: string; // optional date field\n     }>;\n   }\n\n   // Add action types\n   type LifestyleAction = \n     // existing actions\n     | { type: 'ADD_ONE_OFF_PURCHASE', payload: Omit<OneOffPurchase, 'id'> }\n     | { type: 'REMOVE_ONE_OFF_PURCHASE', payload: { id: string } }\n     | { type: 'UPDATE_ONE_OFF_PURCHASE', payload: { id: string, updates: Partial<Omit<OneOffPurchase, 'id'>> } };\n\n   // Update reducer\n   function lifestyleReducer(state: LifestyleState, action: LifestyleAction): LifestyleState {\n     switch (action.type) {\n       // existing cases\n       case 'ADD_ONE_OFF_PURCHASE':\n         return {\n           ...state,\n           oneOffPurchases: [...state.oneOffPurchases, { id: uuidv4(), ...action.payload }]\n         };\n       case 'REMOVE_ONE_OFF_PURCHASE':\n         return {\n           ...state,\n           oneOffPurchases: state.oneOffPurchases.filter(item => item.id !== action.payload.id)\n         };\n       case 'UPDATE_ONE_OFF_PURCHASE':\n         return {\n           ...state,\n           oneOffPurchases: state.oneOffPurchases.map(item => \n             item.id === action.payload.id ? { ...item, ...action.payload.updates } : item\n           )\n         };\n     }\n   }\n   ```\n\n2. Update LifestyleModule.tsx:\n   ```typescript\n   const OneOffPurchasesSection = () => {\n     const { state, dispatch } = useLifestyleContext();\n     const [newPurchase, setNewPurchase] = useState({ name: '', cost: '', targetDate: '' });\n     const [errors, setErrors] = useState<{name?: string, cost?: string}>({});\n     \n     const validateForm = () => {\n       const newErrors: {name?: string, cost?: string} = {};\n       if (!newPurchase.name.trim()) newErrors.name = 'Name is required';\n       if (!newPurchase.cost || isNaN(Number(newPurchase.cost))) newErrors.cost = 'Valid cost is required';\n       setErrors(newErrors);\n       return Object.keys(newErrors).length === 0;\n     };\n     \n     const handleAddPurchase = () => {\n       if (!validateForm()) return;\n       \n       dispatch({\n         type: 'ADD_ONE_OFF_PURCHASE',\n         payload: {\n           name: newPurchase.name.trim(),\n           cost: Number(newPurchase.cost),\n           ...(newPurchase.targetDate ? { targetDate: newPurchase.targetDate } : {})\n         }\n       });\n       \n       // Reset form\n       setNewPurchase({ name: '', cost: '', targetDate: '' });\n     };\n     \n     const totalOneOffCost = state.oneOffPurchases.reduce((sum, item) => sum + item.cost, 0);\n     \n     return (\n       <div className=\"one-off-purchases-section\">\n         {/* Form implementation */}\n         {/* List of purchases with remove buttons */}\n         <div className=\"purchases-total\">\n           Total One-Off Purchases: ${totalOneOffCost.toLocaleString()}\n         </div>\n       </div>\n     );\n   };\n   ```\n</info added on 2025-04-16T20:04:37.983Z>\n\n<info added on 2025-04-16T20:05:49.940Z>\n<info added on 2025-04-17T14:22:18.000Z>\nUI Component Implementation Details:\n\n1. Form Component Structure:\n```tsx\nconst PurchaseForm = () => (\n  <div className=\"purchase-form\">\n    <div className=\"form-row\">\n      <TextField\n        label=\"Purchase Name\"\n        value={newPurchase.name}\n        onChange={(e) => setNewPurchase({...newPurchase, name: e.target.value})}\n        error={!!errors.name}\n        helperText={errors.name}\n        fullWidth\n        size=\"small\"\n        margin=\"dense\"\n      />\n    </div>\n    <div className=\"form-row\">\n      <TextField\n        label=\"Cost ($)\"\n        value={newPurchase.cost}\n        onChange={(e) => setNewPurchase({...newPurchase, cost: e.target.value})}\n        error={!!errors.cost}\n        helperText={errors.cost}\n        type=\"number\"\n        InputProps={{\n          startAdornment: <InputAdornment position=\"start\">$</InputAdornment>,\n        }}\n        size=\"small\"\n        margin=\"dense\"\n      />\n      <TextField\n        label=\"Target Date (Optional)\"\n        type=\"date\"\n        value={newPurchase.targetDate}\n        onChange={(e) => setNewPurchase({...newPurchase, targetDate: e.target.value})}\n        InputLabelProps={{ shrink: true }}\n        size=\"small\"\n        margin=\"dense\"\n      />\n    </div>\n    <Button \n      variant=\"contained\" \n      color=\"primary\" \n      onClick={handleAddPurchase}\n      startIcon={<AddIcon />}\n      size=\"small\"\n    >\n      Add Purchase\n    </Button>\n  </div>\n);\n```\n\n2. Purchase List Component:\n```tsx\nconst PurchaseList = () => (\n  <div className=\"purchases-list\">\n    <Typography variant=\"subtitle1\" gutterBottom>\n      Planned One-Off Purchases\n    </Typography>\n    {state.oneOffPurchases.length === 0 ? (\n      <Typography variant=\"body2\" color=\"textSecondary\">\n        No purchases added yet\n      </Typography>\n    ) : (\n      <List>\n        {state.oneOffPurchases.map((purchase) => (\n          <ListItem \n            key={purchase.id}\n            secondaryAction={\n              <IconButton \n                edge=\"end\" \n                aria-label=\"delete\"\n                onClick={() => dispatch({\n                  type: 'REMOVE_ONE_OFF_PURCHASE',\n                  payload: { id: purchase.id }\n                })}\n              >\n                <DeleteIcon />\n              </IconButton>\n            }\n          >\n            <ListItemText\n              primary={purchase.name}\n              secondary={\n                <>\n                  ${purchase.cost.toLocaleString()}\n                  {purchase.targetDate && ` • Target: ${new Date(purchase.targetDate).toLocaleDateString()}`}\n                </>\n              }\n            />\n          </ListItem>\n        ))}\n      </List>\n    )}\n    <Divider sx={{ my: 2 }} />\n    <Typography variant=\"h6\">\n      Total: ${totalOneOffCost.toLocaleString()}\n    </Typography>\n  </div>\n);\n```\n\n3. Animation and UX Enhancements:\n```tsx\n// Add this to your imports\nimport { CSSTransition, TransitionGroup } from 'react-transition-group';\n\n// Replace the List component with this\n<TransitionGroup component={List}>\n  {state.oneOffPurchases.map((purchase) => (\n    <CSSTransition\n      key={purchase.id}\n      timeout={300}\n      classNames=\"purchase-item\"\n    >\n      <ListItem>\n        {/* ListItem content as before */}\n      </ListItem>\n    </CSSTransition>\n  ))}\n</TransitionGroup>\n\n// Add these styles to your CSS\n.purchase-item-enter {\n  opacity: 0;\n  transform: translateY(-10px);\n}\n.purchase-item-enter-active {\n  opacity: 1;\n  transform: translateY(0);\n  transition: opacity 300ms, transform 300ms;\n}\n.purchase-item-exit {\n  opacity: 1;\n}\n.purchase-item-exit-active {\n  opacity: 0;\n  transform: translateY(-10px);\n  transition: opacity 300ms, transform 300ms;\n}\n```\n\n4. Input Validation Enhancement:\n```typescript\nconst validateForm = () => {\n  const newErrors: {name?: string, cost?: string} = {};\n  \n  // Name validation\n  if (!newPurchase.name.trim()) {\n    newErrors.name = 'Name is required';\n  } else if (newPurchase.name.trim().length > 50) {\n    newErrors.name = 'Name must be 50 characters or less';\n  }\n  \n  // Cost validation\n  if (!newPurchase.cost) {\n    newErrors.cost = 'Cost is required';\n  } else {\n    const costValue = Number(newPurchase.cost);\n    if (isNaN(costValue)) {\n      newErrors.cost = 'Cost must be a valid number';\n    } else if (costValue <= 0) {\n      newErrors.cost = 'Cost must be greater than zero';\n    } else if (costValue > 1000000000) {\n      newErrors.cost = 'Cost must be less than 1 billion';\n    }\n  }\n  \n  setErrors(newErrors);\n  return Object.keys(newErrors).length === 0;\n};\n```\n\n5. Performance Optimization:\n```typescript\n// Memoize the total calculation to prevent unnecessary recalculations\nconst totalOneOffCost = useMemo(() => \n  state.oneOffPurchases.reduce((sum, item) => sum + item.cost, 0),\n  [state.oneOffPurchases]\n);\n\n// Use callback for handlers to prevent unnecessary re-renders\nconst handleAddPurchase = useCallback(() => {\n  if (!validateForm()) return;\n  \n  dispatch({\n    type: 'ADD_ONE_OFF_PURCHASE',\n    payload: {\n      name: newPurchase.name.trim(),\n      cost: Number(newPurchase.cost),\n      ...(newPurchase.targetDate ? { targetDate: newPurchase.targetDate } : {})\n    }\n  });\n  \n  // Reset form\n  setNewPurchase({ name: '', cost: '', targetDate: '' });\n}, [newPurchase, dispatch, validateForm]);\n```\n</info added on 2025-04-17T14:22:18.000Z>\n</info added on 2025-04-16T20:05:49.940Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 3,
          "title": "Create Travel & Holidays Budget Input Section",
          "description": "Implement the section for users to plan and budget for travel and holiday expenses.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create input fields for annual travel budget with currency formatting\n2. Add optional breakdown fields for different types of travel (weekend trips, major vacations, etc.)\n3. Implement a toggle to view monthly equivalent of annual travel budget\n4. Add validation for numerical inputs\n5. Ensure travel budget is incorporated into the overall lifestyle calculations\n6. Test different input combinations and verify correct calculation of totals\n\n<info added on 2025-04-16T20:07:17.346Z>\nImplementation Plan:\n1. Update LifestyleContext.tsx:\n   ```typescript\n   // Add to state interface\n   interface LifestyleState {\n     // existing state properties\n     travelHolidaysBudget: {\n       amount: number;\n       frequency: 'monthly' | 'annual';\n       breakdown: {\n         weekendTrips: number;\n         majorVacations: number;\n         holidayCelebrations: number;\n         other: number;\n       };\n     };\n   }\n\n   // Add action type\n   export const UPDATE_TRAVEL_HOLIDAYS_BUDGET = 'UPDATE_TRAVEL_HOLIDAYS_BUDGET';\n\n   // Add to reducer\n   case UPDATE_TRAVEL_HOLIDAYS_BUDGET:\n     return {\n       ...state,\n       travelHolidaysBudget: {\n         ...state.travelHolidaysBudget,\n         ...action.payload\n       }\n     };\n   ```\n\n2. Create TravelHolidaysBudget.tsx component:\n   ```typescript\n   import React, { useContext } from 'react';\n   import { LifestyleContext, UPDATE_TRAVEL_HOLIDAYS_BUDGET } from '../context/LifestyleContext';\n   import { CurrencyInput, Toggle, Accordion } from '../components/ui';\n\n   const TravelHolidaysBudget: React.FC = () => {\n     const { state, dispatch } = useContext(LifestyleContext);\n     const { travelHolidaysBudget } = state;\n\n     const handleAmountChange = (value: number) => {\n       dispatch({\n         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,\n         payload: { amount: value }\n       });\n     };\n\n     const handleFrequencyToggle = (frequency: 'monthly' | 'annual') => {\n       dispatch({\n         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,\n         payload: { frequency }\n       });\n     };\n\n     const handleBreakdownChange = (category: string, value: number) => {\n       dispatch({\n         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,\n         payload: { \n           breakdown: {\n             ...travelHolidaysBudget.breakdown,\n             [category]: value\n           }\n         }\n       });\n     };\n\n     return (\n       <div className=\"travel-holidays-section\">\n         <h3>Travel & Holidays Budget</h3>\n         <div className=\"input-row\">\n           <CurrencyInput\n             label=\"Budget Amount\"\n             value={travelHolidaysBudget.amount}\n             onChange={handleAmountChange}\n           />\n           <Toggle\n             options={[\n               { label: 'Monthly', value: 'monthly' },\n               { label: 'Annual', value: 'annual' }\n             ]}\n             value={travelHolidaysBudget.frequency}\n             onChange={handleFrequencyToggle}\n           />\n         </div>\n         \n         <Accordion title=\"Budget Breakdown (Optional)\">\n           <div className=\"breakdown-inputs\">\n             {Object.entries(travelHolidaysBudget.breakdown).map(([key, value]) => (\n               <CurrencyInput\n                 key={key}\n                 label={key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}\n                 value={value}\n                 onChange={(val) => handleBreakdownChange(key, val)}\n               />\n             ))}\n           </div>\n         </Accordion>\n         \n         {travelHolidaysBudget.frequency === 'annual' && (\n           <div className=\"monthly-equivalent\">\n             Monthly equivalent: ${(travelHolidaysBudget.amount / 12).toFixed(2)}\n           </div>\n         )}\n       </div>\n     );\n   };\n\n   export default TravelHolidaysBudget;\n   ```\n\n3. Add validation utilities in utils/validation.ts:\n   ```typescript\n   export const validateTravelBudget = (budget: any) => {\n     const errors: Record<string, string> = {};\n     \n     if (isNaN(budget.amount) || budget.amount < 0) {\n       errors.amount = 'Please enter a valid budget amount';\n     }\n     \n     // Validate breakdown values if they exist\n     if (budget.breakdown) {\n       Object.entries(budget.breakdown).forEach(([key, value]) => {\n         if (value !== null && (isNaN(Number(value)) || Number(value) < 0)) {\n           errors[`breakdown.${key}`] = 'Please enter a valid amount';\n         }\n       });\n     }\n     \n     return errors;\n   };\n   ```\n</info added on 2025-04-16T20:07:17.346Z>\n\n<info added on 2025-04-16T20:08:18.681Z>\n<info added on 2025-04-17T14:23:45.129Z>\nUI Styling and Integration Details:\n\n1. Add these styles to the component:\n```css\n.travel-holidays-section {\n  background-color: var(--card-bg);\n  border-radius: 8px;\n  padding: 1.5rem;\n  margin-bottom: 1.5rem;\n  box-shadow: var(--card-shadow);\n}\n\n.breakdown-inputs {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 1rem;\n  margin-top: 1rem;\n}\n\n.monthly-equivalent {\n  margin-top: 1rem;\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n  font-style: italic;\n}\n```\n\n2. Integration with LifestyleModule.tsx:\n```typescript\n// In LifestyleModule.tsx\nimport TravelHolidaysBudget from './TravelHolidaysBudget';\n\n// Add this to the component's JSX\n<div className=\"lifestyle-module-section\">\n  <HousingCosts />\n  <DailyExpenses />\n  <TravelHolidaysBudget /> {/* Add the new component here */}\n  {/* Other lifestyle components */}\n</div>\n```\n\n3. Initialize state in LifestyleContext:\n```typescript\n// Add to initial state\nconst initialState: LifestyleState = {\n  // existing state\n  travelHolidaysBudget: {\n    amount: 0,\n    frequency: 'annual',\n    breakdown: {\n      weekendTrips: 0,\n      majorVacations: 0,\n      holidayCelebrations: 0,\n      other: 0\n    }\n  }\n};\n```\n\n4. Add calculation utility in utils/calculations.ts:\n```typescript\nexport const calculateMonthlyTravelBudget = (budget: any) => {\n  if (!budget || typeof budget.amount !== 'number') {\n    return 0;\n  }\n  \n  return budget.frequency === 'monthly' \n    ? budget.amount \n    : budget.amount / 12;\n};\n\n// Update the overall monthly expenses calculation\nexport const calculateTotalMonthlyExpenses = (state: any) => {\n  return (\n    calculateMonthlyHousingCosts(state.housingCosts) +\n    calculateMonthlyDailyExpenses(state.dailyExpenses) +\n    calculateMonthlyTravelBudget(state.travelHolidaysBudget) +\n    // other expense categories\n  );\n};\n```\n\n5. Add unit tests for the component:\n```typescript\n// TravelHolidaysBudget.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport TravelHolidaysBudget from './TravelHolidaysBudget';\nimport { LifestyleProvider } from '../context/LifestyleContext';\n\ndescribe('TravelHolidaysBudget', () => {\n  test('renders the component with initial values', () => {\n    render(\n      <LifestyleProvider>\n        <TravelHolidaysBudget />\n      </LifestyleProvider>\n    );\n    \n    expect(screen.getByText('Travel & Holidays Budget')).toBeInTheDocument();\n    expect(screen.getByLabelText('Budget Amount')).toHaveValue('0');\n    expect(screen.getByText('Annual')).toHaveClass('active');\n  });\n  \n  test('toggles between monthly and annual frequency', () => {\n    render(\n      <LifestyleProvider>\n        <TravelHolidaysBudget />\n      </LifestyleProvider>\n    );\n    \n    fireEvent.click(screen.getByText('Monthly'));\n    expect(screen.getByText('Monthly')).toHaveClass('active');\n    expect(screen.queryByText('Monthly equivalent:')).not.toBeInTheDocument();\n    \n    fireEvent.click(screen.getByText('Annual'));\n    expect(screen.getByText('Annual')).toHaveClass('active');\n    expect(screen.getByText(/Monthly equivalent:/)).toBeInTheDocument();\n  });\n  \n  test('updates breakdown values correctly', () => {\n    render(\n      <LifestyleProvider>\n        <TravelHolidaysBudget />\n      </LifestyleProvider>\n    );\n    \n    fireEvent.click(screen.getByText('Budget Breakdown (Optional)'));\n    \n    const weekendTripsInput = screen.getByLabelText('Weekend Trips');\n    fireEvent.change(weekendTripsInput, { target: { value: '500' } });\n    expect(weekendTripsInput).toHaveValue('500');\n  });\n});\n```\n</info added on 2025-04-17T14:23:45.129Z>\n</info added on 2025-04-16T20:08:18.681Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 4,
          "title": "Develop Home Services Section with Multiple Service Inputs",
          "description": "Build the interface for users to input various home service costs including cleaning, childcare, gardening, and pet care.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a section with separate input fields for each home service category (cleaner, babysitter, gardening, pet care)\n2. For each service, include fields for frequency (weekly, monthly, etc.) and cost per occurrence\n3. Calculate and display monthly and annual totals for each service\n4. Add an 'Other' category with custom label for additional services\n5. Implement validation for all numerical inputs\n6. Test calculations with various frequency and cost combinations\n\n<info added on 2025-04-16T20:09:02.576Z>\nImplementation Plan:\n1. Update LifestyleContext.tsx:\n   ```typescript\n   // Add to initial state\n   homeServices: {\n     cleaner: { amount: 0, frequency: 'monthly' },\n     babysitter: { amount: 0, frequency: 'weekly' },\n     gardening: { amount: 0, frequency: 'monthly' },\n     petCare: { amount: 0, frequency: 'monthly' },\n     other: { amount: 0, frequency: 'monthly', label: '' }\n   }\n   \n   // Add action type\n   export const UPDATE_HOME_SERVICE = 'UPDATE_HOME_SERVICE';\n   \n   // Add to reducer\n   case UPDATE_HOME_SERVICE:\n     return {\n       ...state,\n       homeServices: {\n         ...state.homeServices,\n         [action.payload.serviceName]: {\n           ...state.homeServices[action.payload.serviceName],\n           ...action.payload.data\n         }\n       }\n     };\n   ```\n\n2. Create HomeServicesSection.tsx component:\n   ```typescript\n   const frequencies = [\n     { value: 'weekly', label: 'Weekly', multiplier: 4.33 },\n     { value: 'biweekly', label: 'Bi-weekly', multiplier: 2.17 },\n     { value: 'monthly', label: 'Monthly', multiplier: 1 }\n   ];\n   \n   // Include helper function to calculate annual costs\n   const calculateAnnualCost = (amount, frequency) => {\n     const multiplier = frequencies.find(f => f.value === frequency).multiplier;\n     return amount * multiplier * 12;\n   };\n   ```\n\n3. Implement validation with error handling:\n   ```typescript\n   const validateAmount = (value) => {\n     if (isNaN(value) || value < 0) return 'Please enter a valid amount';\n     return null;\n   };\n   ```\n\n4. Add summary section to display total monthly and annual home service costs across all categories.\n</info added on 2025-04-16T20:09:02.576Z>\n\n<info added on 2025-04-16T20:10:29.188Z>\n<info added on 2025-04-17T14:32:18.123Z>\nImplementation Details:\n\n1. Type definitions for better type safety:\n   ```typescript\n   // In LifestyleContext.tsx\n   export type HomeServiceName = 'cleaner' | 'babysitter' | 'gardening' | 'petCare' | 'other';\n   export type HomeServiceFrequency = 'weekly' | 'biweekly' | 'monthly';\n   \n   export interface HomeServiceEntry {\n     amount: number;\n     frequency: HomeServiceFrequency;\n     label?: string; // Optional for the 'other' category\n   }\n   \n   export interface HomeServicesState {\n     [key in HomeServiceName]: HomeServiceEntry;\n   }\n   ```\n\n2. Helper function for rendering service inputs in LifestyleModule.tsx:\n   ```typescript\n   const renderServiceInput = (\n     serviceName: HomeServiceName, \n     serviceLabel: string, \n     state: LifestyleState, \n     dispatch: React.Dispatch<LifestyleAction>\n   ) => {\n     const service = state.homeServices[serviceName];\n     \n     return (\n       <div className=\"service-input-container\">\n         <label htmlFor={`${serviceName}-amount`}>{serviceLabel}</label>\n         <div className=\"input-group\">\n           <CurrencyInput\n             id={`${serviceName}-amount`}\n             value={service.amount}\n             onValueChange={(value) => \n               dispatch({\n                 type: UPDATE_HOME_SERVICE,\n                 payload: {\n                   serviceName,\n                   data: { amount: value || 0 }\n                 }\n               })\n             }\n           />\n           <FrequencyToggle\n             value={service.frequency}\n             onChange={(frequency) => \n               dispatch({\n                 type: UPDATE_HOME_SERVICE,\n                 payload: {\n                   serviceName,\n                   data: { frequency }\n                 }\n               })\n             }\n           />\n         </div>\n         <div className=\"cost-summary\">\n           <span>Monthly: ${calculateMonthlyCost(service.amount, service.frequency)}</span>\n           <span>Yearly: ${calculateAnnualCost(service.amount, service.frequency)}</span>\n         </div>\n       </div>\n     );\n   };\n   ```\n\n3. FrequencyToggle component implementation:\n   ```typescript\n   const FrequencyToggle: React.FC<{\n     value: HomeServiceFrequency;\n     onChange: (frequency: HomeServiceFrequency) => void;\n   }> = ({ value, onChange }) => {\n     return (\n       <div className=\"frequency-toggle\">\n         {frequencies.map(freq => (\n           <button\n             key={freq.value}\n             className={value === freq.value ? 'active' : ''}\n             onClick={() => onChange(freq.value as HomeServiceFrequency)}\n           >\n             {freq.label}\n           </button>\n         ))}\n       </div>\n     );\n   };\n   ```\n\n4. Custom input for \"Other\" category:\n   ```typescript\n   const renderOtherServiceInput = (state, dispatch) => {\n     const service = state.homeServices.other;\n     \n     return (\n       <div className=\"service-input-container\">\n         <div className=\"other-service-header\">\n           <input\n             type=\"text\"\n             placeholder=\"Other service...\"\n             value={service.label || ''}\n             onChange={(e) => \n               dispatch({\n                 type: UPDATE_HOME_SERVICE,\n                 payload: {\n                   serviceName: 'other',\n                   data: { label: e.target.value }\n                 }\n               })\n             }\n           />\n         </div>\n         {/* Rest of input similar to renderServiceInput */}\n       </div>\n     );\n   };\n   ```\n\n5. Total calculation function:\n   ```typescript\n   const calculateTotalHomeServices = (homeServices: HomeServicesState) => {\n     let monthlyTotal = 0;\n     let annualTotal = 0;\n     \n     Object.values(homeServices).forEach(service => {\n       if (service.amount) {\n         const monthly = calculateMonthlyCost(service.amount, service.frequency);\n         monthlyTotal += monthly;\n         annualTotal += monthly * 12;\n       }\n     });\n     \n     return { monthlyTotal, annualTotal };\n   };\n   ```\n\n6. CSS for the home services section:\n   ```css\n   .home-services-section {\n     display: flex;\n     flex-direction: column;\n     gap: 1.5rem;\n   }\n   \n   .service-input-container {\n     padding: 1rem;\n     border-radius: 8px;\n     background-color: var(--color-background-light);\n     box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n   }\n   \n   .frequency-toggle {\n     display: flex;\n     border-radius: 4px;\n     overflow: hidden;\n   }\n   \n   .frequency-toggle button {\n     flex: 1;\n     padding: 0.5rem;\n     border: 1px solid var(--color-border);\n     background: none;\n     cursor: pointer;\n   }\n   \n   .frequency-toggle button.active {\n     background-color: var(--color-primary);\n     color: white;\n   }\n   \n   .cost-summary {\n     display: flex;\n     justify-content: space-between;\n     margin-top: 0.5rem;\n     font-size: 0.9rem;\n     color: var(--color-text-secondary);\n   }\n   ```\n</info added on 2025-04-17T14:32:18.123Z>\n</info added on 2025-04-16T20:10:29.188Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 5,
          "title": "Implement Contingency Field with Percentage/Fixed Amount Options",
          "description": "Create functionality for users to add a contingency amount either as a fixed sum or as a percentage of total lifestyle costs.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a toggle between 'Fixed Amount' and 'Percentage' options for contingency\n2. For fixed amount, add a currency-formatted input field\n3. For percentage, add a percentage input with preview of calculated amount\n4. Calculate the total lifestyle costs from all previous sections\n5. Add the contingency amount to the total and display both the contingency and grand total\n6. Test both percentage and fixed amount modes with various inputs\n7. Verify contingency updates correctly when any lifestyle cost changes\n\n<info added on 2025-04-16T20:11:01.571Z>\nImplementation Plan:\n1. Update LifestyleContext.tsx:\n   ```typescript\n   // Add to state interface\n   interface LifestyleState {\n     // existing state properties\n     contingency: {\n       type: 'fixed' | 'percentage';\n       value: number;\n     };\n   }\n   \n   // Add action type\n   export const UPDATE_CONTINGENCY = 'UPDATE_CONTINGENCY';\n   \n   // Add action interface\n   interface UpdateContingencyAction {\n     type: typeof UPDATE_CONTINGENCY;\n     payload: {\n       type: 'fixed' | 'percentage';\n       value: number;\n     };\n   }\n   \n   // Update reducer\n   case UPDATE_CONTINGENCY:\n     return {\n       ...state,\n       contingency: action.payload\n     };\n   ```\n\n2. Update LifestyleModule.tsx:\n   ```typescript\n   const ContingencySection = () => {\n     const { state, dispatch } = useLifestyleContext();\n     const baseLifestyleCost = calculateTotalMonthlyLifestyleCosts(state);\n     \n     const handleTypeChange = (type: 'fixed' | 'percentage') => {\n       dispatch({\n         type: UPDATE_CONTINGENCY,\n         payload: { type, value: state.contingency.value }\n       });\n     };\n     \n     const handleValueChange = (value: number) => {\n       dispatch({\n         type: UPDATE_CONTINGENCY,\n         payload: { type: state.contingency.type, value }\n       });\n     };\n     \n     const contingencyAmount = state.contingency.type === 'fixed' \n       ? state.contingency.value \n       : (baseLifestyleCost * state.contingency.value / 100);\n     \n     return (\n       <Section title=\"Contingency\">\n         <ToggleButtonGroup\n           value={state.contingency.type}\n           exclusive\n           onChange={(_, value) => handleTypeChange(value)}\n         >\n           <ToggleButton value=\"fixed\">Fixed Amount</ToggleButton>\n           <ToggleButton value=\"percentage\">Percentage</ToggleButton>\n         </ToggleButtonGroup>\n         \n         {state.contingency.type === 'fixed' ? (\n           <CurrencyInput\n             value={state.contingency.value}\n             onChange={handleValueChange}\n             label=\"Contingency Amount\"\n           />\n         ) : (\n           <Box>\n             <PercentageInput\n               value={state.contingency.value}\n               onChange={handleValueChange}\n               label=\"Contingency Percentage\"\n             />\n             <Typography variant=\"body2\">\n               {formatCurrency(contingencyAmount)} ({state.contingency.value}% of {formatCurrency(baseLifestyleCost)})\n             </Typography>\n           </Box>\n         )}\n         \n         <Typography variant=\"subtitle1\" sx={{ mt: 2 }}>\n           Total with Contingency: {formatCurrency(baseLifestyleCost + contingencyAmount)}\n         </Typography>\n       </Section>\n     );\n   };\n   \n   // Helper function to calculate total monthly lifestyle costs\n   const calculateTotalMonthlyLifestyleCosts = (state: LifestyleState) => {\n     const generalShoppingTotal = calculateMonthlyEquivalent(state.generalShopping);\n     const oneOffsTotal = calculateMonthlyEquivalent(state.oneOffs);\n     const travelTotal = calculateMonthlyEquivalent(state.travel);\n     const homeServicesTotal = calculateMonthlyEquivalent(state.homeServices);\n     \n     return generalShoppingTotal + oneOffsTotal + travelTotal + homeServicesTotal;\n   };\n   ```\n</info added on 2025-04-16T20:11:01.571Z>\n\n<info added on 2025-04-16T20:12:23.576Z>\n<info added on 2025-04-17T14:23:45.000Z>\nImplementation Notes:\n\n1. Edge Case Handling:\n   ```typescript\n   // Add validation to prevent negative values\n   const handleValueChange = (value: number) => {\n     const sanitizedValue = Math.max(0, value); // Prevent negative values\n     dispatch({\n       type: UPDATE_CONTINGENCY,\n       payload: { type: state.contingency.type, value: sanitizedValue }\n     });\n   };\n   ```\n\n2. Performance Optimization:\n   ```typescript\n   // Memoize the base lifestyle cost calculation to prevent unnecessary recalculations\n   const baseLifestyleCost = useMemo(() => \n     calculateTotalMonthlyLifestyleCosts(state), \n     [state.generalShopping, state.oneOffs, state.travel, state.homeServices]\n   );\n   ```\n\n3. Accessibility Improvements:\n   ```typescript\n   <ToggleButtonGroup\n     value={state.contingency.type}\n     exclusive\n     onChange={(_, value) => handleTypeChange(value)}\n     aria-label=\"contingency calculation method\"\n   >\n     <ToggleButton value=\"fixed\" aria-label=\"fixed amount\">Fixed Amount</ToggleButton>\n     <ToggleButton value=\"percentage\" aria-label=\"percentage\">Percentage</ToggleButton>\n   </ToggleButtonGroup>\n   ```\n\n4. Default State Initialization:\n   ```typescript\n   // In initialState\n   contingency: {\n     type: 'percentage', // Default to percentage\n     value: 10 // Default to 10%\n   }\n   ```\n\n5. Unit Tests:\n   ```typescript\n   // ContingencySection.test.tsx\n   test('updates contingency correctly when base costs change', () => {\n     // Setup with mock state and dispatch\n     // Render component\n     // Update a lifestyle cost category\n     // Verify contingency amount updates correctly\n   });\n\n   test('switches between fixed and percentage modes correctly', () => {\n     // Setup with initial percentage mode\n     // Render component\n     // Click fixed amount toggle\n     // Verify input field changes appropriately\n     // Verify calculated amount updates correctly\n   });\n   ```\n\n6. Debounce Implementation:\n   ```typescript\n   // Add debounce to prevent excessive recalculations during rapid input changes\n   const debouncedHandleValueChange = useCallback(\n     debounce((value: number) => {\n       handleValueChange(value);\n     }, 300),\n     [state.contingency.type]\n   );\n   ```\n</info added on 2025-04-17T14:23:45.000Z>\n</info added on 2025-04-16T20:12:23.576Z>",
          "status": "done",
          "parentTaskId": 11
        }
      ]
    },
    {
      "id": 12,
      "title": "Build Utilities Module",
      "description": "Create the utilities section for electricity, water, gas/heating, internet, and mobile costs.",
      "status": "done",
      "dependencies": [
        4
      ],
      "priority": "medium",
      "details": "Implement input fields for monthly utility costs including electricity, water, gas/heating. Add internet & mobile cost inputs. Calculate monthly averages and totals. Consider seasonal variations option for utilities like heating.",
      "testStrategy": "Verify that all utility inputs are correctly captured and summed. Test that monthly averages are calculated correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Basic Utilities Input Form Structure",
          "description": "Build the core UI structure for the utilities module with input fields for all required utility types",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a new component called 'UtilitiesModule'\n2. Design a form layout with separate sections for each utility type (electricity, water, gas/heating, internet, mobile)\n3. Implement input fields for each utility with appropriate labels and validation\n4. Add currency formatting and input validation for monetary values\n5. Create state management for storing input values\n6. Add a basic monthly total calculation that sums all utility inputs\n7. Style the component according to the application's design system\n\nTesting approach:\n- Verify all input fields render correctly\n- Test input validation for negative numbers and non-numeric inputs\n- Confirm the monthly total updates correctly when values change\n\n<info added on 2025-04-16T21:17:57.390Z>\nImplementation Plan:\n1. Create a new file `UtilitiesModule.tsx` in the components directory.\n2. Define interface `UtilitiesProps` type with properties: `electricity: string, water: string, gasHeating: string, internet: string, mobile: string, onUtilitiesChange: (field: string, value: string) => void`.\n3. Use DaisyUI/Tailwind components (`card`, `card-body`, `form-control`, `input`) for layout, similar to existing form components.\n4. Add `CurrencyInput` component for each utility field (Electricity, Water, Gas/Heating, Internet, Mobile), binding value to props and onChange to onUtilitiesChange handler.\n5. Calculate the sum of all utility prop values (converting to numbers) and display it formatted as currency (€ XXX.XX) in a dedicated section with a distinct visual style.\n6. Export the component as default for easy importing.\n7. Implement a helper function `validateUtilityInput` to ensure only valid numeric values are accepted.\n8. Add responsive design considerations to ensure the form works well on mobile devices.\n</info added on 2025-04-16T21:17:57.390Z>\n\n<info added on 2025-04-16T21:18:08.263Z>\n<info added>\nImplementation Plan:\n1. Create a new file `UtilitiesModule.tsx` in the components directory.\n2. Define interface `UtilitiesProps` type with properties: `electricity: string, water: string, gasHeating: string, internet: string, mobile: string, onUtilitiesChange: (field: string, value: string) => void`.\n3. Use DaisyUI/Tailwind components (`card`, `card-body`, `form-control`, `input`) for layout, similar to existing form components.\n4. Add `CurrencyInput` component for each utility field (Electricity, Water, Gas/Heating, Internet, Mobile), binding value to props and onChange to onUtilitiesChange handler.\n5. Calculate the sum of all utility prop values (converting to numbers) and display it formatted as currency (€ XXX.XX) in a dedicated section with a distinct visual style.\n6. Export the component as default for easy importing.\n7. Implement a helper function `validateUtilityInput` to ensure only valid numeric values are accepted.\n8. Add responsive design considerations to ensure the form works well on mobile devices.\n</info added>\n</info added on 2025-04-16T21:18:08.263Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 2,
          "title": "Implement Seasonal Variation Options",
          "description": "Add functionality to account for seasonal variations in utility costs",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Extend the UtilitiesModule to include toggles for enabling seasonal variations for applicable utilities (primarily electricity and gas/heating)\n2. When seasonal variation is enabled for a utility, display input fields for each season (Winter, Spring, Summer, Fall) or allow monthly inputs\n3. Implement logic to calculate the annual average based on seasonal inputs\n4. Update the monthly calculation to use seasonal values when available\n5. Add visual indicators showing which utilities have seasonal variations enabled\n6. Implement data validation for seasonal inputs\n\nTesting approach:\n- Test toggling seasonal variations on/off for different utilities\n- Verify calculations correctly average seasonal values\n- Confirm the UI adapts appropriately when seasonal mode is enabled/disabled\n\n<info added on 2025-04-16T21:25:18.024Z>\nHere's the additional implementation information:\n\n```typescript\n// 1. Extended UtilitiesProps interface\ninterface UtilitiesProps {\n  // Existing props\n  isSeasonalElectricity: boolean;\n  isSeasonalGasHeating: boolean;\n  electricityWinter: number;\n  electricitySpring: number;\n  electricitySummer: number;\n  electricityFall: number;\n  gasHeatingWinter: number;\n  gasHeatingSpring: number;\n  gasHeatingSummer: number;\n  gasHeatingFall: number;\n  // ...other props\n}\n\n// 2. Toggle component implementation\nconst SeasonalToggle = ({ isEnabled, onChange, label }) => (\n  <div className=\"form-control\">\n    <label className=\"label cursor-pointer\">\n      <span className=\"label-text\">{label}</span>\n      <input \n        type=\"checkbox\" \n        className=\"toggle toggle-primary\" \n        checked={isEnabled} \n        onChange={e => onChange(e.target.checked)} \n      />\n    </label>\n  </div>\n);\n\n// 3. Seasonal inputs rendering logic\n{isSeasonalElectricity ? (\n  <div className=\"grid grid-cols-2 md:grid-cols-4 gap-2\">\n    <InputField label=\"Winter\" value={electricityWinter} onChange={val => handleSeasonalChange('electricityWinter', val)} />\n    <InputField label=\"Spring\" value={electricitySpring} onChange={val => handleSeasonalChange('electricitySpring', val)} />\n    <InputField label=\"Summer\" value={electricitySummer} onChange={val => handleSeasonalChange('electricitySummer', val)} />\n    <InputField label=\"Fall\" value={electricityFall} onChange={val => handleSeasonalChange('electricityFall', val)} />\n  </div>\n) : (\n  <InputField label=\"Monthly\" value={electricity} onChange={val => handleChange('electricity', val)} />\n)}\n\n// 4. Calculation function for seasonal averaging\nconst calculateSeasonalAverage = (winter, spring, summer, fall) => {\n  return (winter + spring + summer + fall) / 4;\n};\n\n// 5. Update to calculateTotal function\nconst calculateTotal = () => {\n  const electricityCost = isSeasonalElectricity \n    ? calculateSeasonalAverage(electricityWinter, electricitySpring, electricitySummer, electricityFall)\n    : electricity;\n  \n  const gasHeatingCost = isSeasonalGasHeating\n    ? calculateSeasonalAverage(gasHeatingWinter, gasHeatingSpring, gasHeatingSummer, gasHeatingFall)\n    : gasHeating;\n    \n  // Continue with other utilities and return total\n};\n```\n\nInclude visual indicators next to seasonal toggles using a small badge or icon that shows \"Seasonal\" when enabled. Add validation to ensure all seasonal inputs are valid numbers and provide appropriate error messages.\n</info added on 2025-04-16T21:25:18.024Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 3,
          "title": "Integrate Utilities Module with Budget System",
          "description": "Connect the utilities module to the overall budget system and implement advanced calculations",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation details:\n1. Create a data service to handle utilities data persistence\n2. Implement methods to save and retrieve utilities data\n3. Connect the utilities module to the main budget calculation system\n4. Add summary statistics for utilities (percentage of total budget, year-over-year comparisons if historical data exists)\n5. Implement a utilities dashboard widget showing key metrics\n6. Add export functionality for utilities data\n7. Implement comparison features to benchmark against average utility costs\n\nTesting approach:\n- Verify data persistence works correctly\n- Test integration with the main budget system\n- Confirm summary statistics calculate correctly\n- Validate that the utilities data appears correctly in reports and dashboards\n\n<info added on 2025-04-16T21:26:37.360Z>\nFor the core integration with the budget system, here's a more detailed implementation plan:\n\n```javascript\n// In src/app/page.tsx\nconst [utilitiesState, setUtilitiesState] = useState({\n  electricity: { monthly: 0, seasonal: false, winter: 0, summer: 0 },\n  water: { monthly: 0, seasonal: false, winter: 0, summer: 0 },\n  gas: { monthly: 0, seasonal: false, winter: 0, summer: 0 },\n  internet: { monthly: 0 },\n  phone: { monthly: 0 },\n  other: { monthly: 0 }\n});\n\nconst handleUtilitiesChange = (category, field, value) => {\n  setUtilitiesState(prev => ({\n    ...prev,\n    [category]: {\n      ...prev[category],\n      [field]: value\n    }\n  }));\n};\n\n// Calculate total utilities cost for budget summary\nconst calculateUtilitiesTotals = () => {\n  let annualTotal = 0;\n  \n  Object.keys(utilitiesState).forEach(utility => {\n    const item = utilitiesState[utility];\n    if (item.seasonal) {\n      // 6 months of each season\n      annualTotal += (item.winter * 6) + (item.summer * 6);\n    } else {\n      annualTotal += item.monthly * 12;\n    }\n  });\n  \n  return {\n    monthly: annualTotal / 12,\n    annual: annualTotal\n  };\n};\n\n// Pass to BudgetSummaryDisplay\nconst utilityTotals = calculateUtilitiesTotals();\n```\n\nInclude a simple context provider to avoid prop drilling if the component hierarchy becomes complex:\n\n```javascript\n// src/contexts/UtilitiesContext.js\nimport { createContext, useContext } from 'react';\n\nconst UtilitiesContext = createContext();\n\nexport const useUtilities = () => useContext(UtilitiesContext);\n\nexport const UtilitiesProvider = ({ children, value }) => (\n  <UtilitiesContext.Provider value={value}>\n    {children}\n  </UtilitiesContext.Provider>\n);\n```\n</info added on 2025-04-16T21:26:37.360Z>",
          "status": "done",
          "parentTaskId": 12
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Education Module",
      "description": "Build the education section with public/private toggle and associated costs.",
      "status": "pending",
      "dependencies": [
        4,
        6
      ],
      "priority": "medium",
      "details": "Create public/private education toggle for each child in the household. For private education, include annual tuition input and show monthly payment breakdown. Add fields for extra school costs like books, uniforms, and activities. Calculate education totals per child and household.",
      "testStrategy": "Test that education options appear correctly based on household composition. Verify calculations for monthly payment breakdowns from annual tuition.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Education Type Toggle and Basic Structure",
          "description": "Implement the core education module structure with public/private education toggle for each child",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create an Education component that integrates with the existing household data structure\n2. Add a public/private toggle switch for each child in the household\n3. Implement conditional rendering based on the education type selection\n4. Store education type selection in state for each child\n5. Create the basic layout structure for the education module\n6. Add validation to ensure each child has an education type selected\n\nTesting approach:\n- Verify the toggle works correctly for each child\n- Confirm the UI updates appropriately when switching between public and private\n- Test with various household compositions (different numbers of children)\n- Ensure state is properly maintained when navigating between sections\n\n<info added on 2025-04-16T21:38:01.533Z>\nI've reviewed the implementation and can provide these additional technical details:\n\nFor the Education.tsx component:\n- Use a Map structure like `Map<string, 'public' | 'private'>` for the education type state to ensure type safety\n- Implement the toggle using the existing design system's Toggle component with proper ARIA attributes\n- Add data-testid attributes (e.g., `data-testid=\"education-toggle-primary-0\"`) to facilitate testing\n\nState management improvements:\n- Structure the state object as `{[childId: string]: {educationType: 'public' | 'private', gradeLevel?: string}}` to accommodate future education details\n- Use React.useReducer instead of useState for more predictable state transitions when handling multiple children\n\nValidation implementation:\n- Add form validation using the existing validation framework\n- Create a validateEducation() function that returns error messages for any child missing an education type\n- Connect validation to the \"Continue\" button's onClick handler\n\nFor conditional rendering:\n- Implement a getEducationFormByType(type: 'public' | 'private', childData) function that returns the appropriate form components\n- Use React.memo to prevent unnecessary re-renders when toggling between children\n</info added on 2025-04-16T21:38:01.533Z>",
          "status": "in-progress",
          "parentTaskId": 13
        },
        {
          "id": 2,
          "title": "Implement Private Education Cost Inputs",
          "description": "Add tuition and additional education cost input fields for children with private education",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create input fields for annual tuition costs that appear only when private education is selected\n2. Add input fields for additional education expenses (books, uniforms, activities, etc.)\n3. Implement proper number formatting and validation for all cost inputs\n4. Create helper functions to convert annual costs to monthly amounts\n5. Store all education cost data in the application state\n6. Ensure inputs have appropriate labels and help text\n\nTesting approach:\n- Test input validation for all fields (negative numbers, non-numeric input, etc.)\n- Verify conditional rendering works correctly based on education type\n- Test data persistence when switching between children or sections\n- Confirm proper number formatting for currency inputs",
          "status": "pending",
          "parentTaskId": 13
        },
        {
          "id": 3,
          "title": "Calculate and Display Education Cost Summaries",
          "description": "Implement calculations for per-child and household education totals with monthly breakdown",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Create functions to calculate total education costs per child (tuition + additional costs)\n2. Implement monthly payment breakdown calculations for each child\n3. Add a summary section showing education costs per child\n4. Calculate and display total household education expenses\n5. Integrate education totals with the overall household budget calculations\n6. Add visual elements (charts or tables) to display the education cost breakdown\n\nTesting approach:\n- Verify calculations are correct for various input scenarios\n- Test with multiple children having different education types\n- Confirm monthly breakdowns are calculated correctly\n- Check that household totals accurately reflect the sum of all children's education costs\n- Test integration with the overall budget summary",
          "status": "pending",
          "parentTaskId": 13
        }
      ]
    },
    {
      "id": 14,
      "title": "Develop Healthcare Module",
      "description": "Create the healthcare section with coverage type and cost inputs.",
      "status": "pending",
      "dependencies": [
        4,
        6
      ],
      "priority": "medium",
      "details": "Implement healthcare type selection (Public, Private, Hybrid) for each household member. Include monthly premium inputs for private options. Add estimated out-of-pocket expense fields for GP visits, dental, and prescriptions. Include section for known recurring medical costs.",
      "testStrategy": "Test that healthcare options appear for each household member. Verify healthcare cost calculations are correct based on selected options."
    },
    {
      "id": 15,
      "title": "Build Emergency Buffer Calculator",
      "description": "Implement the emergency savings buffer calculator with runway visualization.",
      "status": "pending",
      "dependencies": [
        8,
        9,
        10,
        11,
        12,
        13,
        14
      ],
      "priority": "medium",
      "details": "Create inputs for target number of months of coverage and current reserve amount. Calculate fixed expenses from previously entered data. Implement a visual runway meter showing months of financial coverage. Add recommendations based on common financial advice.",
      "testStrategy": "Test that fixed expenses are correctly pulled from other modules. Verify runway calculation accuracy. Ensure the visual meter updates correctly based on inputs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Data Model for Emergency Buffer Calculator",
          "description": "Define the data structure to store emergency buffer information including target months, current reserve amount, and fixed expenses.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new EmergencyBufferModel class with properties for targetMonths, currentReserve, and fixedExpenses\n2. Add methods to calculate total monthly fixed expenses\n3. Add method to calculate current runway (months of coverage)\n4. Implement data validation for inputs\n5. Create unit tests to verify calculations\n\nTesting approach:\n- Test calculation accuracy with various input combinations\n- Verify edge cases (zero expenses, zero reserve, etc.)\n- Ensure proper data validation",
          "status": "pending",
          "parentTaskId": 15
        },
        {
          "id": 2,
          "title": "Implement Fixed Expense Aggregation from Existing Data",
          "description": "Create functionality to aggregate and calculate fixed monthly expenses from previously entered financial data.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a service to fetch existing expense data from other modules\n2. Implement logic to filter and identify fixed expenses\n3. Calculate total monthly fixed expenses\n4. Add caching mechanism to avoid recalculating when expense data hasn't changed\n5. Connect this service to the EmergencyBufferModel\n\nTesting approach:\n- Mock expense data sources for testing\n- Verify correct identification of fixed expenses\n- Test aggregation with various expense scenarios\n- Ensure proper error handling for missing data",
          "status": "pending",
          "parentTaskId": 15
        },
        {
          "id": 3,
          "title": "Build User Interface for Emergency Buffer Inputs",
          "description": "Create the UI components for users to input target months of coverage and current reserve amount.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create form inputs for target months (slider or number input)\n2. Add input for current emergency reserve amount\n3. Implement real-time validation with appropriate feedback\n4. Connect inputs to the EmergencyBufferModel\n5. Add help text explaining each input's purpose\n\nTesting approach:\n- Test input validation for various scenarios\n- Verify UI updates when model changes\n- Test accessibility compliance\n- Ensure responsive design works on different screen sizes",
          "status": "pending",
          "parentTaskId": 15
        },
        {
          "id": 4,
          "title": "Develop Runway Visualization Component",
          "description": "Create a visual meter showing months of financial coverage based on current reserve and fixed expenses.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Design a visual meter component (progress bar, gauge, etc.)\n2. Implement color coding based on coverage status (red for < 3 months, yellow for 3-5, green for 6+)\n3. Add animations for transitions between states\n4. Display numeric values alongside visual representation\n5. Ensure the visualization updates when inputs change\n\nTesting approach:\n- Test rendering with different data scenarios\n- Verify color changes at appropriate thresholds\n- Test animation behavior\n- Ensure accessibility for color-blind users (include text indicators)",
          "status": "pending",
          "parentTaskId": 15
        },
        {
          "id": 5,
          "title": "Implement Recommendation Engine",
          "description": "Create a system to generate personalized recommendations based on the user's emergency buffer status and common financial advice.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "Implementation steps:\n1. Define a set of recommendation rules based on financial best practices\n2. Implement logic to select appropriate recommendations based on:\n   - Current runway vs target months\n   - Fixed expense ratio to income\n   - Current savings rate\n3. Create UI components to display recommendations\n4. Add links to educational resources for each recommendation\n5. Implement priority sorting for recommendations\n\nTesting approach:\n- Test recommendation generation with various financial scenarios\n- Verify correct prioritization of advice\n- Test UI rendering of recommendations\n- Ensure recommendations are actionable and clear",
          "status": "pending",
          "parentTaskId": 15
        }
      ]
    },
    {
      "id": 16,
      "title": "Implement FX Sensitivity Module",
      "description": "Create the foreign exchange sensitivity analysis tools.",
      "status": "pending",
      "dependencies": [
        3,
        8
      ],
      "priority": "medium",
      "details": "Build exchange rate override input that defaults to API values. Implement FX movement sliders or percentage shock simulation. Create visualizations showing impact of FX changes on budget. Ensure all modules display dual-currency output (origin vs. destination).",
      "testStrategy": "Test that manual overrides work correctly. Verify that FX changes propagate through all calculations. Test edge cases with extreme exchange rate values.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Exchange Rate API Integration Service",
          "description": "Develop a service to fetch and manage foreign exchange rates from an external API, with caching capabilities and error handling.",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a service class that handles API calls to fetch current exchange rates\n2. Implement caching mechanism to store rates for configurable time periods\n3. Add error handling for API failures with fallback to cached values\n4. Create methods to convert between currencies using the fetched rates\n5. Add logging for rate updates and conversion operations\n6. Testing approach: Write unit tests with mocked API responses, test caching behavior, and verify conversion calculations",
          "status": "pending",
          "parentTaskId": 16
        },
        {
          "id": 2,
          "title": "Build Exchange Rate Override UI Component",
          "description": "Create a user interface component allowing users to view current exchange rates and manually override them with custom values.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Design a UI component showing current exchange rates from the API service\n2. Add input fields for manual rate overrides with validation\n3. Implement toggle switches to enable/disable specific rate overrides\n4. Create visual indicators showing which rates are using API values vs overrides\n5. Add reset functionality to revert to API values\n6. Testing approach: Create component tests verifying UI rendering, input validation, and proper state management for overrides",
          "status": "pending",
          "parentTaskId": 16
        },
        {
          "id": 3,
          "title": "Implement FX Movement Simulation Controls",
          "description": "Develop slider controls and percentage input fields that allow users to simulate currency value fluctuations.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation details:\n1. Create slider components with appropriate ranges for FX movement simulation\n2. Add percentage input fields synchronized with slider positions\n3. Implement bidirectional binding between sliders and input fields\n4. Add presets for common shock scenarios (e.g., 5%, 10%, 15% movements)\n5. Create a reset button to return all simulations to baseline\n6. Testing approach: Test slider-input synchronization, boundary values, and preset functionality through component tests",
          "status": "pending",
          "parentTaskId": 16
        },
        {
          "id": 4,
          "title": "Develop FX Impact Calculation Engine",
          "description": "Create the core calculation logic to determine how exchange rate changes affect budget figures across the application.",
          "dependencies": [
            1,
            3
          ],
          "details": "Implementation details:\n1. Develop algorithms to recalculate budget values based on exchange rate changes\n2. Create a calculation pipeline that processes all budget items with the simulated rates\n3. Implement delta calculations to show differences between baseline and simulated scenarios\n4. Add percentage and absolute change calculations for key metrics\n5. Optimize for performance with large datasets\n6. Testing approach: Write comprehensive unit tests with various exchange rate scenarios, verify calculations against manually verified examples",
          "status": "pending",
          "parentTaskId": 16
        },
        {
          "id": 5,
          "title": "Create FX Impact Visualizations",
          "description": "Develop charts and visual representations showing the impact of exchange rate changes on budget items.",
          "dependencies": [
            4
          ],
          "details": "Implementation details:\n1. Design and implement bar/column charts showing before/after values for key budget items\n2. Create heat maps highlighting areas most sensitive to FX changes\n3. Develop waterfall charts showing cumulative impact across categories\n4. Add interactive tooltips with detailed information on hover\n5. Implement export functionality for visualizations\n6. Testing approach: Test chart rendering with various data scenarios, verify tooltip content, and test responsiveness across screen sizes",
          "status": "pending",
          "parentTaskId": 16
        },
        {
          "id": 6,
          "title": "Implement Dual-Currency Display Integration",
          "description": "Modify all relevant application modules to display values in both origin and destination currencies based on current exchange rates or overrides.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "Implementation details:\n1. Create a dual-currency display component that can be reused across the application\n2. Modify existing budget display components to incorporate the dual-currency view\n3. Add configuration options for users to select which currencies to display\n4. Implement visual indicators showing which values are affected by overrides or simulations\n5. Ensure consistent formatting and alignment of dual-currency values\n6. Testing approach: Create integration tests verifying dual-currency display across different application modules, test with various override and simulation scenarios",
          "status": "pending",
          "parentTaskId": 16
        }
      ]
    },
    {
      "id": 17,
      "title": "Develop Dashboard Summary View",
      "description": "Create the comprehensive dashboard summary with key financial metrics.",
      "status": "pending",
      "dependencies": [
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16
      ],
      "priority": "high",
      "details": "Implement summary cards showing total monthly and annual income & expenses. Calculate and display disposable income projection. Show required gross income to meet lifestyle target. Calculate and display the felt cost of private school (factoring in tax savings from NHR). Create rent vs. buy comparison visualization. Add scenario save and clone functionality.",
      "testStrategy": "Verify all summary calculations against manual calculations. Test that all data from other modules is correctly reflected in the summary. Ensure visualizations accurately represent the data.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Dashboard Layout and Summary Cards Structure",
          "description": "Implement the basic dashboard layout with placeholders for all summary components and create the structure for summary cards showing monthly and annual income/expenses.",
          "dependencies": [],
          "details": "1. Design a responsive grid layout for the dashboard with appropriate spacing and sections\n2. Create reusable card components with title, value, and optional comparison indicators\n3. Implement placeholder cards for total monthly income, monthly expenses, annual income, and annual expenses\n4. Add styling for positive/negative values with appropriate color coding\n5. Ensure mobile responsiveness with appropriate breakpoints\n6. Test the layout across different screen sizes and ensure all placeholders render correctly",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 2,
          "title": "Implement Income and Expense Summary Calculations",
          "description": "Connect the summary cards to actual data and implement the calculations for total monthly and annual income and expenses.",
          "dependencies": [
            1
          ],
          "details": "1. Create data aggregation functions to sum all income sources by month and year\n2. Implement expense aggregation functions to total all expenses by month and year\n3. Connect the summary cards created in subtask 1 to these calculation functions\n4. Add number formatting with appropriate currency symbols and decimal places\n5. Implement comparison with previous period (month/year) if historical data is available\n6. Test with various income and expense scenarios to verify calculations\n7. Add loading states for when calculations are in progress",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 3,
          "title": "Develop Disposable Income Projection Component",
          "description": "Calculate and display disposable income projections based on current income and expense data.",
          "dependencies": [
            2
          ],
          "details": "1. Create a projection algorithm that calculates disposable income (income minus expenses) over time\n2. Implement a visualization component (chart or graph) to display the projection\n3. Add toggles for monthly vs. annual view\n4. Include a summary card showing current disposable income and projected change\n5. Add tooltip explanations for the projection methodology\n6. Implement color coding to indicate positive/negative trends\n7. Test with various income/expense scenarios to verify projection accuracy\n8. Ensure the component updates when underlying data changes",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 4,
          "title": "Implement Required Gross Income Calculator",
          "description": "Create a component that calculates and displays the required gross income to meet the user's lifestyle target.",
          "dependencies": [
            2
          ],
          "details": "1. Design an input interface for users to set their lifestyle target\n2. Implement the calculation logic that factors in taxes and expenses to determine required gross income\n3. Create a visual indicator showing the gap between current and required income\n4. Add explanatory text about how the calculation works\n5. Implement sensitivity analysis to show how changes in expenses affect required income\n6. Test with various tax scenarios and lifestyle targets\n7. Add the ability to save target lifestyle goals",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 5,
          "title": "Develop Private School Cost Analysis Component",
          "description": "Calculate and display the felt cost of private school, factoring in tax savings from NHR (Non-Habitual Resident) status.",
          "dependencies": [
            2
          ],
          "details": "1. Create input fields for private school tuition costs\n2. Implement calculation logic for tax savings under NHR status\n3. Calculate the net 'felt cost' after tax considerations\n4. Create a comparative visualization showing costs with and without NHR benefits\n5. Add explanatory tooltips about the NHR program and how it affects education costs\n6. Include a summary card showing the annual savings from NHR status\n7. Test with various tuition costs and tax scenarios\n8. Ensure all calculations update when tax parameters change",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 6,
          "title": "Create Rent vs. Buy Comparison Visualization",
          "description": "Implement an interactive visualization comparing the financial implications of renting versus buying property.",
          "dependencies": [
            2
          ],
          "details": "1. Design a side-by-side comparison layout for rent vs. buy scenarios\n2. Implement calculation logic for total cost of ownership for buying (mortgage, taxes, maintenance, appreciation)\n3. Create calculation logic for total rental costs over time\n4. Develop an interactive chart showing the crossover point where buying becomes more economical than renting\n5. Add sliders for key variables (interest rates, property appreciation, rent increases)\n6. Include a summary of key metrics (break-even time, 5-year cost difference, etc.)\n7. Test with various property values, rental rates, and timeframes\n8. Ensure all visualizations update dynamically when inputs change",
          "status": "pending",
          "parentTaskId": 17
        },
        {
          "id": 7,
          "title": "Implement Scenario Management Functionality",
          "description": "Add the ability to save, clone, and manage different financial scenarios within the dashboard.",
          "dependencies": [
            3,
            4,
            5,
            6
          ],
          "details": "1. Design a scenario management UI with save, clone, and delete options\n2. Implement data structure for storing complete scenario configurations\n3. Create save functionality that captures all current dashboard settings and calculations\n4. Implement clone functionality to duplicate scenarios for comparison\n5. Add a scenario selector dropdown or tabs in the dashboard header\n6. Create a comparison view to see multiple scenarios side by side\n7. Implement local storage or database persistence for saved scenarios\n8. Test scenario switching to ensure all dashboard components update correctly\n9. Add export/import functionality for scenarios",
          "status": "pending",
          "parentTaskId": 17
        }
      ]
    },
    {
      "id": 18,
      "title": "Implement Portugal NHR Tax Logic",
      "description": "Create the tax calculation logic specific to Portugal's Non-Habitual Resident program.",
      "status": "done",
      "dependencies": [
        7,
        8
      ],
      "priority": "high",
      "details": "Implement simplified tax calculation for Portugal's NHR regime. Include logic for different income types (employment, passive, etc.). Create functions to calculate net income from gross based on the tax regime. Add explanatory tooltips about tax assumptions.",
      "testStrategy": "Test tax calculations against known examples. Verify that different income types are taxed correctly under NHR rules. Test edge cases and boundary conditions.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Portugal NHR Tax Rate Constants and Configuration",
          "description": "Define all tax rate constants, thresholds, and configuration parameters needed for Portugal's NHR tax calculations.",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a new file `portugal_nhr_tax_config.js` to store all tax constants\n2. Define tax rates for different income types (employment income at 20%, passive income at 10%, etc.)\n3. Define income thresholds and brackets if applicable\n4. Include social security contribution rates\n5. Add configuration for different income categories (employment, self-employment, capital gains, dividends, rental, etc.)\n6. Document each constant with comments explaining its purpose and source\n7. Testing approach: Create unit tests to verify constants match official Portugal NHR tax documentation",
          "status": "done",
          "parentTaskId": 18
        },
        {
          "id": 2,
          "title": "Implement Core NHR Tax Calculation Functions",
          "description": "Create the core calculation functions that will handle the basic tax computations for different income types under the NHR regime.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Create a new file `portugal_nhr_calculator.js`\n2. Implement function `calculateEmploymentTax(grossIncome)` for employment income\n3. Implement function `calculatePassiveIncomeTax(grossIncome, incomeType)` for passive income types\n4. Implement function `calculateSocialSecurityContributions(grossIncome, incomeType)` \n5. Create helper functions for any special deductions or exemptions\n6. Ensure all functions properly use the constants defined in subtask 1\n7. Testing approach: Write unit tests with various income scenarios to verify calculations match expected outcomes based on Portugal's tax laws",
          "status": "done",
          "parentTaskId": 18
        },
        {
          "id": 3,
          "title": "Develop Income Type Classification System",
          "description": "Create a system to classify different income streams according to Portugal's NHR tax categories and apply the appropriate tax calculation.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation details:\n1. Create an income classifier function that categorizes income based on source and type\n2. Implement logic to determine if income qualifies for NHR benefits\n3. Create mapping between application's income categories and Portugal's tax categories\n4. Implement function `classifyIncomeForNHR(incomeSource, incomeAmount, additionalDetails)`\n5. Add validation to ensure income classification meets NHR requirements\n6. Create a router function that directs income to the appropriate tax calculation function\n7. Testing approach: Test with various income scenarios to ensure proper classification and routing to correct tax functions",
          "status": "done",
          "parentTaskId": 18
        },
        {
          "id": 4,
          "title": "Implement Comprehensive Gross-to-Net Calculator",
          "description": "Create a unified calculator that processes multiple income streams, applies appropriate NHR tax rules, and calculates total net income.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation details:\n1. Create main function `calculatePortugalNHRTax(incomeStreams)` that accepts an array of income objects\n2. For each income stream, classify and calculate applicable tax using functions from subtasks 2 and 3\n3. Implement aggregation logic to combine tax results across different income types\n4. Calculate total tax liability and net income\n5. Return detailed breakdown of calculations for each income stream and totals\n6. Handle edge cases like income caps, minimum tax thresholds, etc.\n7. Testing approach: Create integration tests with complex income scenarios combining multiple income types",
          "status": "done",
          "parentTaskId": 18
        },
        {
          "id": 5,
          "title": "Integrate NHR Calculator with Application Data Flow",
          "description": "Connect the Portugal NHR tax calculator with the application's existing data structures and user flow.",
          "dependencies": [
            4
          ],
          "details": "Implementation details:\n1. Modify application's main tax calculation pipeline to include Portugal NHR option\n2. Create adapter functions to convert application data format to format required by NHR calculator\n3. Implement country detection logic to apply NHR calculations only when Portugal is selected\n4. Add user option to toggle between standard Portugal tax calculation and NHR regime\n5. Ensure calculator properly handles currency conversions if needed\n6. Update any dependent visualizations or reports to display NHR-specific information\n7. Testing approach: Create end-to-end tests that verify the entire flow from user input to displayed results",
          "status": "done",
          "parentTaskId": 18
        },
        {
          "id": 6,
          "title": "Add User-Facing Explanations and Documentation",
          "description": "Implement tooltips, explanations, and documentation to help users understand the Portugal NHR tax calculations.",
          "dependencies": [
            5
          ],
          "details": "Implementation details:\n1. Create tooltip content explaining NHR eligibility requirements\n2. Add explanatory text for each income type and how it's taxed under NHR\n3. Implement tooltips that appear when hovering over tax calculation results\n4. Create a detailed breakdown view that explains each step of the calculation\n5. Add disclaimers about tax assumptions and recommendation to consult a tax professional\n6. Include references to relevant Portuguese tax legislation\n7. Testing approach: Conduct user testing to ensure explanations are clear and helpful; verify all tooltips display correctly across devices",
          "status": "done",
          "parentTaskId": 18
        }
      ]
    },
    {
      "id": 19,
      "title": "Create User Flow Navigation",
      "description": "Implement the step-by-step navigation flow as outlined in the PRD.",
      "status": "pending",
      "dependencies": [
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17
      ],
      "priority": "high",
      "details": "Create a multi-step form navigation with progress indicator. Implement next/previous buttons between sections. Add validation to ensure required fields are completed before proceeding. Create a sidebar or top navigation for quick jumping between sections.",
      "testStrategy": "Test the complete user flow from start to finish. Verify that validation works correctly and prevents proceeding with invalid data. Test navigation between non-sequential sections.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Multi-Step Form Structure and State Management",
          "description": "Set up the basic structure for the multi-step form and implement the state management to track form data across steps.",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a parent component to house the multi-step form\n2. Define the data model for all form fields across all steps\n3. Set up state management (using Context API, Redux, or local state with prop drilling)\n4. Create a mechanism to persist form state between steps\n5. Implement functions to handle form data changes\n6. Add state for tracking current active step\n\nTesting approach:\n- Verify state updates correctly when form fields change\n- Confirm state persists when navigating between steps\n- Test that the form data model captures all required fields",
          "status": "pending",
          "parentTaskId": 19
        },
        {
          "id": 2,
          "title": "Implement Step Navigation Controls",
          "description": "Create the next/previous navigation buttons and the logic to move between form steps.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Create reusable Next and Previous button components\n2. Implement navigation logic to move forward and backward between steps\n3. Add conditional rendering to show/hide buttons based on current step (e.g., no Previous on first step)\n4. Create event handlers for the navigation buttons\n5. Ensure form state is preserved during navigation\n6. Add transition animations between steps for better UX\n\nTesting approach:\n- Verify navigation works correctly in both directions\n- Test edge cases (first step, last step)\n- Confirm animations work smoothly\n- Ensure state is maintained when navigating",
          "status": "pending",
          "parentTaskId": 19
        },
        {
          "id": 3,
          "title": "Build Progress Indicator Component",
          "description": "Create a visual progress indicator that shows users their current position in the multi-step form.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Design and implement a progress bar or stepper component\n2. Connect the progress indicator to the current step state\n3. Style the indicator to show completed, current, and upcoming steps\n4. Add labels for each step in the progress indicator\n5. Ensure the indicator updates correctly when steps change\n6. Make the progress indicator responsive for different screen sizes\n\nTesting approach:\n- Verify the indicator correctly reflects the current step\n- Test responsive behavior on different screen sizes\n- Ensure accessibility requirements are met\n- Check that visual states (completed, current, upcoming) render correctly",
          "status": "pending",
          "parentTaskId": 19
        },
        {
          "id": 4,
          "title": "Implement Form Validation System",
          "description": "Create a validation system to ensure required fields are completed before allowing users to proceed to the next step.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation details:\n1. Define validation rules for each form field\n2. Implement validation functions for different field types\n3. Create error message display components\n4. Add validation checks when users attempt to proceed to next step\n5. Implement real-time validation feedback as users type\n6. Add visual indicators for invalid fields\n7. Ensure Next button is disabled until required fields are valid\n\nTesting approach:\n- Test validation with valid and invalid inputs\n- Verify error messages display correctly\n- Confirm Next button behavior based on validation state\n- Test real-time validation feedback",
          "status": "pending",
          "parentTaskId": 19
        },
        {
          "id": 5,
          "title": "Create Quick Navigation Sidebar/Topbar",
          "description": "Implement a sidebar or top navigation component that allows users to quickly jump between form sections.",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "Implementation details:\n1. Design and implement a sidebar or top navigation component\n2. Create navigation links for each form step\n3. Connect navigation to the step state management\n4. Add validation checks before allowing navigation to ensure data integrity\n5. Style the navigation to indicate completed, current, and locked steps\n6. Implement responsive design for the navigation component\n7. Add tooltips to explain navigation restrictions when steps are locked\n\nTesting approach:\n- Verify navigation correctly jumps to selected steps\n- Test validation prevents navigation to future steps when required fields are incomplete\n- Confirm visual indicators for step states work correctly\n- Test responsive behavior on different screen sizes",
          "status": "pending",
          "parentTaskId": 19
        },
        {
          "id": 6,
          "title": "Implement Responsive Design and Final Integration",
          "description": "Ensure the entire multi-step form navigation system is responsive and integrate all components into a cohesive user experience.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Implementation details:\n1. Apply responsive design principles to all form components\n2. Implement media queries for different screen sizes\n3. Create mobile-specific navigation patterns when needed\n4. Ensure consistent styling across all components\n5. Optimize transitions and animations for performance\n6. Perform final integration of all components\n7. Add keyboard navigation support for accessibility\n8. Implement focus management between steps\n\nTesting approach:\n- Test the complete form flow on various devices and screen sizes\n- Verify all components work together seamlessly\n- Conduct accessibility testing (keyboard navigation, screen readers)\n- Perform end-to-end testing of the complete user flow\n- Test edge cases like browser refresh and back button behavior",
          "status": "pending",
          "parentTaskId": 19
        }
      ]
    },
    {
      "id": 20,
      "title": "Implement Scenario Save Functionality",
      "description": "Create functionality to save and load budget scenarios.",
      "status": "pending",
      "dependencies": [
        4,
        17
      ],
      "priority": "medium",
      "details": "Implement local storage saving of complete scenarios. Create UI for naming and managing saved scenarios. Add export functionality to JSON format. For MVP, focus on client-side storage rather than server persistence.",
      "testStrategy": "Test saving and loading scenarios from local storage. Verify that all data is correctly preserved when loading a saved scenario. Test edge cases like loading with incompatible schema versions."
    },
    {
      "id": 21,
      "title": "Develop Responsive Design",
      "description": "Ensure the application is fully responsive across desktop, tablet, and mobile devices.",
      "status": "pending",
      "dependencies": [
        2,
        19
      ],
      "priority": "medium",
      "details": "Implement responsive layouts using Tailwind's responsive utilities. Create mobile-specific component variants where needed. Test and optimize for touch interfaces. Ensure all forms and inputs are usable on smaller screens.",
      "testStrategy": "Test the application on various device sizes and orientations. Verify that all functionality works correctly on mobile devices. Check for any UI/UX issues specific to touch interfaces.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up responsive breakpoints and base layout structure",
          "description": "Configure Tailwind's responsive breakpoints and establish the base responsive layout structure for the application",
          "dependencies": [],
          "details": "1. Review and customize Tailwind's default breakpoints in tailwind.config.js to match project requirements (sm, md, lg, xl, 2xl)\n2. Create a responsive container component that will serve as the base layout wrapper\n3. Implement a responsive navigation system that transforms into a mobile menu on smaller screens\n4. Set up responsive grid layouts for main content areas using Tailwind's grid utilities\n5. Test the base layout structure across different viewport sizes\n6. Document the responsive strategy and breakpoint standards for the team",
          "status": "pending",
          "parentTaskId": 21
        },
        {
          "id": 2,
          "title": "Implement responsive typography and spacing system",
          "description": "Create a consistent responsive typography and spacing system that scales appropriately across device sizes",
          "dependencies": [
            1
          ],
          "details": "1. Define a responsive typography scale using Tailwind's text utilities with different sizes at different breakpoints\n2. Create utility classes for responsive margins and padding that adjust based on screen size\n3. Implement responsive font sizes for headings, body text, and UI elements\n4. Ensure proper line heights and letter spacing for readability on all devices\n5. Test text overflow and wrapping behavior on small screens\n6. Create a documentation page showing the typography system across breakpoints",
          "status": "pending",
          "parentTaskId": 21
        },
        {
          "id": 3,
          "title": "Develop mobile-specific component variants",
          "description": "Create and implement mobile-specific variants for complex components that require different layouts or interactions on smaller screens",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Identify components that need mobile-specific variants (data tables, complex forms, charts, etc.)\n2. Create simplified mobile versions of data tables that stack or reformat content\n3. Implement collapsible sections for complex forms on mobile\n4. Develop touch-friendly alternatives for hover-dependent components\n5. Create mobile-specific navigation patterns (bottom tabs, etc.)\n6. Test each component variant on actual mobile devices\n7. Document when and how to use each component variant",
          "status": "pending",
          "parentTaskId": 21
        },
        {
          "id": 4,
          "title": "Optimize forms and inputs for touch interfaces",
          "description": "Ensure all forms and input elements are usable and accessible on touch devices with appropriate sizing and spacing",
          "dependencies": [
            3
          ],
          "details": "1. Increase touch target sizes for all interactive elements (minimum 44x44px)\n2. Add appropriate spacing between touch targets to prevent accidental taps\n3. Implement mobile-optimized form layouts with full-width inputs\n4. Create touch-friendly custom form controls (dropdowns, date pickers, etc.)\n5. Ensure form validation messages are clearly visible on small screens\n6. Test form completion on various mobile devices and browsers\n7. Implement mobile-specific keyboard types for different input fields",
          "status": "pending",
          "parentTaskId": 21
        },
        {
          "id": 5,
          "title": "Conduct comprehensive responsive testing and optimization",
          "description": "Perform thorough testing across devices and browsers, and optimize performance for mobile users",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Create a testing matrix covering key device/browser combinations\n2. Test the application on actual physical devices (not just browser emulation)\n3. Identify and fix layout issues, touch target problems, and visual inconsistencies\n4. Optimize image loading with responsive images (srcset, sizes attributes)\n5. Implement performance optimizations for mobile users (reduced animations, etc.)\n6. Test and optimize load times on slower mobile connections\n7. Document any device-specific workarounds or considerations\n8. Create a responsive design QA checklist for future features",
          "status": "pending",
          "parentTaskId": 21
        }
      ]
    },
    {
      "id": 22,
      "title": "Implement Form Validation",
      "description": "Add comprehensive validation to all input forms.",
      "status": "pending",
      "dependencies": [
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15
      ],
      "priority": "medium",
      "details": "Implement client-side validation for all numeric inputs. Add format validation for currency and percentage inputs. Create helpful error messages for invalid inputs. Implement real-time validation feedback.",
      "testStrategy": "Test validation with valid and invalid inputs. Verify that appropriate error messages are displayed. Test form submission with invalid data to ensure it's prevented.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Validation Utility Functions",
          "description": "Develop a set of reusable validation utility functions for different input types",
          "dependencies": [],
          "details": "Implement a validation utility module with functions for: 1) Numeric validation (integers, decimals, ranges), 2) Currency format validation (proper currency symbols, decimal places), 3) Percentage validation (0-100% range, decimal precision), 4) Common input validation (required fields, min/max length). Each function should return a boolean result and an appropriate error message. Test each function with various valid and invalid inputs to ensure accuracy. These utilities will serve as the foundation for all form validation throughout the application.",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 2,
          "title": "Implement Form Input Component with Validation",
          "description": "Create or enhance form input components that incorporate validation capabilities",
          "dependencies": [
            1
          ],
          "details": "Modify existing input components or create new ones that: 1) Accept validation rules as props, 2) Use the validation utility functions from subtask 1, 3) Track input validity state, 4) Support different input types (text, number, currency, percentage), 5) Include proper ARIA attributes for accessibility. Implement internal state management to track validation status. Test components individually with various validation rules to ensure they correctly validate inputs and maintain proper state.",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 3,
          "title": "Develop Real-time Validation Feedback UI",
          "description": "Create visual feedback mechanisms for real-time validation results",
          "dependencies": [
            2
          ],
          "details": "Implement UI elements and styles for validation feedback: 1) Error message display component with appropriate styling, 2) Visual indicators for valid/invalid inputs (border colors, icons), 3) Tooltip or inline help text for validation requirements, 4) Animation for transitions between states. Connect these UI elements to the validation state from subtask 2. Ensure feedback is accessible and follows design system guidelines. Test with screen readers and keyboard navigation to verify accessibility compliance.",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 4,
          "title": "Integrate Form-Level Validation Logic",
          "description": "Implement form-level validation that coordinates validation across multiple inputs",
          "dependencies": [
            2,
            3
          ],
          "details": "Create a form validation manager that: 1) Tracks validation state of all inputs within a form, 2) Provides form-level validation methods (validateAll, resetAll), 3) Prevents submission of invalid forms, 4) Handles interdependent field validation (where one field's validity depends on another), 5) Manages focus movement to invalid fields. Implement this as a higher-order component or context provider. Test with complex forms containing multiple interdependent fields to ensure proper validation coordination.",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 5,
          "title": "Apply Validation to All Application Forms",
          "description": "Systematically implement validation across all forms in the application",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "For each form in the application: 1) Identify all inputs requiring validation, 2) Define appropriate validation rules using the utility functions, 3) Apply the enhanced input components with validation, 4) Implement form-level validation using the form validation manager, 5) Test each form with valid and invalid inputs, 6) Verify error messages are clear and helpful, 7) Ensure real-time feedback works correctly. Create a validation test plan document to track progress across all forms. Conduct user testing to verify validation messages are understandable and helpful.",
          "status": "pending",
          "parentTaskId": 22
        }
      ]
    },
    {
      "id": 23,
      "title": "Create Help Text and Tooltips",
      "description": "Add contextual help text and tooltips throughout the application.",
      "status": "pending",
      "dependencies": [
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18
      ],
      "priority": "low",
      "details": "Add information icons with tooltips explaining concepts and calculations. Create help text for complex inputs. Add explanations of tax implications and financial concepts. Ensure help text is clear and concise.",
      "testStrategy": "Review all help text for clarity and accuracy. Test tooltip functionality across different browsers and devices."
    },
    {
      "id": 24,
      "title": "Implement Error Handling",
      "description": "Add comprehensive error handling throughout the application.",
      "status": "pending",
      "dependencies": [
        3,
        19
      ],
      "priority": "medium",
      "details": "Implement error boundaries to catch and display React errors. Add error handling for API calls with appropriate user feedback. Create fallback UI for when components fail. Implement logging for debugging purposes.",
      "testStrategy": "Test error scenarios by forcing API failures and component errors. Verify that appropriate error messages are displayed to users. Check that the application can recover from errors."
    },
    {
      "id": 25,
      "title": "Optimize Performance",
      "description": "Optimize application performance for smooth user experience.",
      "status": "pending",
      "dependencies": [
        17,
        19
      ],
      "priority": "low",
      "details": "Implement memoization for expensive calculations. Optimize component rendering with React.memo and useMemo. Add loading states for async operations. Implement virtualization for long lists if needed.",
      "testStrategy": "Measure and compare performance before and after optimizations. Test with large datasets to ensure the application remains responsive. Use React DevTools to identify and address performance bottlenecks.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Performance Profiling and Benchmarking",
          "description": "Set up performance profiling tools and establish baseline metrics to identify bottlenecks in the application",
          "dependencies": [],
          "details": "1. Install React DevTools and Chrome Performance tab for profiling\n2. Create a performance testing script that measures key metrics (FPS, load time, time to interactive)\n3. Identify the top 5 performance bottlenecks in the application\n4. Document baseline metrics for each page/component\n5. Set up Lighthouse CI or similar tool for automated performance testing\n6. Test on both high-end and low-end devices to establish comprehensive baselines\n7. Create a performance budget based on findings",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 2,
          "title": "Implement Memoization for Expensive Calculations",
          "description": "Apply memoization techniques to prevent redundant calculations and improve performance",
          "dependencies": [
            1
          ],
          "details": "1. Identify expensive calculations in the codebase using the profiling data from subtask 1\n2. Implement useMemo for complex derived state calculations\n3. Create custom memoization utilities for non-React calculations\n4. Apply memoization to data transformation functions\n5. Implement reselect or similar library for Redux selectors if applicable\n6. Test before/after performance impact of each memoization implementation\n7. Document memoization patterns used for future reference",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 3,
          "title": "Optimize Component Rendering",
          "description": "Prevent unnecessary re-renders and optimize component rendering cycles",
          "dependencies": [
            1
          ],
          "details": "1. Identify components that re-render excessively using React DevTools Profiler\n2. Apply React.memo to functional components that render often but with the same props\n3. Implement custom comparison functions for React.memo where default shallow comparison is insufficient\n4. Use useCallback for event handlers and functions passed as props\n5. Restructure component tree to isolate frequently changing state\n6. Fix any anti-patterns like creating new objects/arrays in render\n7. Measure and document rendering performance improvements",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 4,
          "title": "Implement Loading States and Async Operation Optimization",
          "description": "Add proper loading states and optimize asynchronous operations for better user experience",
          "dependencies": [
            1
          ],
          "details": "1. Implement skeleton screens for primary content areas during loading\n2. Add loading indicators for user-initiated actions\n3. Implement debouncing for search inputs and other frequent user interactions\n4. Set up request cancellation for obsolete API calls\n5. Implement data prefetching for anticipated user actions\n6. Add error boundaries to prevent cascading failures\n7. Implement retry logic for failed network requests\n8. Test and measure perceived performance improvements",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 5,
          "title": "Implement Virtualization for Long Lists",
          "description": "Apply virtualization techniques to efficiently render large data sets",
          "dependencies": [
            1,
            3
          ],
          "details": "1. Identify lists or grids in the application that contain more than 50 items\n2. Select appropriate virtualization library (react-window, react-virtualized, or similar)\n3. Implement virtualized lists to replace existing inefficient list rendering\n4. Add infinite scrolling or pagination where appropriate\n5. Optimize item rendering within virtualized lists using memoization techniques\n6. Implement data chunking for large datasets\n7. Test virtualization performance on various devices and screen sizes\n8. Measure and document memory usage and rendering performance improvements",
          "status": "pending",
          "parentTaskId": 25
        }
      ]
    },
    {
      "id": 26,
      "title": "Create Clone Scenario Functionality",
      "description": "Implement the ability to clone and modify existing scenarios.",
      "status": "pending",
      "dependencies": [
        20
      ],
      "priority": "low",
      "details": "Add a clone button to saved scenarios. Implement logic to create a copy with a new name. Allow users to modify cloned scenarios independently. Update UI to clearly indicate which scenario is being viewed/edited.",
      "testStrategy": "Test cloning scenarios and verify that changes to the clone don't affect the original. Verify that all data is correctly copied when cloning."
    },
    {
      "id": 27,
      "title": "Implement Vercel Deployment",
      "description": "Set up deployment to Vercel as specified in the PRD.",
      "status": "pending",
      "dependencies": [
        1,
        24
      ],
      "priority": "low",
      "details": "Configure Vercel project settings. Set up environment variables for API keys. Configure build settings and deployment branches. Set up preview deployments for pull requests.",
      "testStrategy": "Verify successful deployment to Vercel. Test that the deployed application functions correctly. Check that environment variables are properly configured."
    },
    {
      "id": 28,
      "title": "Add Print and Export Functionality",
      "description": "Implement functionality to print or export budget summaries.",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "low",
      "details": "Create a print-friendly view of the budget summary. Implement export to PDF functionality. Add option to export data to CSV format. Ensure exported documents are well-formatted and include all relevant information.",
      "testStrategy": "Test printing from different browsers. Verify that PDF exports contain all necessary information and are properly formatted. Test CSV exports for data integrity."
    },
    {
      "id": 29,
      "title": "Create User Documentation",
      "description": "Develop comprehensive user documentation and help guides.",
      "status": "pending",
      "dependencies": [
        19,
        23
      ],
      "priority": "low",
      "details": "Create a user guide explaining how to use the application. Document all features and their purposes. Include examples and use cases. Create FAQ section addressing common questions.",
      "testStrategy": "Review documentation for clarity and completeness. Have test users attempt to follow the documentation to complete tasks."
    },
    {
      "id": 30,
      "title": "Implement Analytics",
      "description": "Add basic analytics to track usage patterns and identify improvement areas.",
      "status": "pending",
      "dependencies": [
        19,
        27
      ],
      "priority": "low",
      "details": "Implement client-side analytics to track feature usage. Add event tracking for key user actions. Create a simple dashboard for viewing analytics data. Ensure compliance with privacy regulations.",
      "testStrategy": "Verify that analytics events are correctly triggered by user actions. Test that no sensitive user data is being collected. Check that analytics don't negatively impact application performance."
    }
  ],
  "metadata": {
    "projectName": "Living Abroad Budgeting Tool Implementation",
    "totalTasks": 30,
    "sourceFile": "PRD-v3.md",
    "generatedAt": "2023-11-14"
  }
}